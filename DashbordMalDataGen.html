<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SynDataGen - Advanced Analytics Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #3b82f6;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #06b6d4;
            --dark: #1f2937;
            --light: #f9fafb;
            --sidebar-width: 280px;
            --navbar-height: 64px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', 'Roboto', sans-serif;
            background: #f9fafb;
            color: #1f2937;
            transition: all 0.3s ease;
        }

        body.dark-mode {
            background: #0f172a;
            color: #f8fafc;
        }

        /* Top Navbar - FIXED */
        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--navbar-height);
            background: white;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            padding: 0 2rem;
            z-index: 1000;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        body.dark-mode .navbar {
            background: #1e293b;
            border-bottom-color: #334155;
        }

        .nav-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .nav-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .menu-toggle {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: inherit;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: background 0.2s;
        }

        .menu-toggle:hover {
            background: rgba(0,0,0,0.05);
        }

        body.dark-mode .menu-toggle:hover {
            background: rgba(255,255,255,0.1);
        }

        .logo {
            font-size: 1.25rem;
            font-weight: 900;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .logo i {
            font-size: 1.5rem;
        }

        .nav-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .nav-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            color: inherit;
            font-size: 1.125rem;
            transition: all 0.2s;
            position: relative;
        }

        .nav-btn:hover {
            background: rgba(0,0,0,0.05);
        }

        body.dark-mode .nav-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .nav-badge {
            position: absolute;
            top: 0;
            right: 0;
            background: var(--danger);
            color: white;
            font-size: 0.65rem;
            padding: 0.125rem 0.375rem;
            border-radius: 9999px;
            font-weight: 600;
        }

        /* Sidebar - FIXED */
        .sidebar {
            position: fixed;
            left: 0;
            top: var(--navbar-height);
            width: var(--sidebar-width);
            height: calc(100vh - var(--navbar-height));
            background: white;
            border-right: 1px solid #e5e7eb;
            overflow-y: auto;
            transition: transform 0.3s ease;
            z-index: 999;
        }

        body.dark-mode .sidebar {
            background: #1e293b;
            border-right-color: #334155;
        }

        .sidebar.collapsed {
            transform: translateX(-100%);
        }

        .sidebar-section {
            padding: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
        }

        body.dark-mode .sidebar-section {
            border-bottom-color: #334155;
        }

        .sidebar-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            color: #9ca3af;
            margin-bottom: 1rem;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .experiment-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .experiment-item {
            padding: 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            display: flex;
            flex-direction: column;
        }

        body.dark-mode .experiment-item {
            background: #0f172a;
            border-color: #334155;
        }

        .experiment-item:hover {
            border-color: var(--primary);
            transform: translateX(4px);
        }

        .experiment-item.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-color: var(--primary);
            color: white;
        }

        .experiment-action-btn {
            background: rgba(0, 0, 0, 0.05);
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            color: inherit;
        }

        .experiment-action-btn:hover {
            background: rgba(0, 0, 0, 0.1);
            transform: scale(1.1);
        }

        .experiment-item.active .experiment-action-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .experiment-item.active .experiment-action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        body.dark-mode .experiment-action-btn {
            background: rgba(255, 255, 255, 0.05);
        }

        body.dark-mode .experiment-action-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .experiment-name {
            font-weight: 700;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .experiment-meta {
            display: flex;
            gap: 0.75rem;
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .experiment-item.active .experiment-meta {
            opacity: 1;
        }

        .meta-badge {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .quick-actions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .action-btn {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            color: inherit;
            text-decoration: none;
        }

        body.dark-mode .action-btn {
            background: #0f172a;
            border-color: #334155;
        }

        .action-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Main Content */
        .main-content {
            margin-left: var(--sidebar-width);
            margin-top: var(--navbar-height);
            padding: 2rem;
            min-height: calc(100vh - var(--navbar-height));
            transition: margin-left 0.3s ease;
        }

        .main-content.expanded {
            margin-left: 0;
        }

        /* Upload Section */
        .upload-section {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 70vh;
        }

        .upload-container {
            text-align: center;
            max-width: 600px;
            padding: 3rem;
        }

        .upload-icon {
            font-size: 4rem;
            color: var(--primary);
            margin-bottom: 1.5rem;
        }

        .upload-title {
            font-size: 2rem;
            font-weight: 900;
            margin-bottom: 1rem;
        }

        .upload-subtitle {
            font-size: 1.125rem;
            color: #6b7280;
            margin-bottom: 2rem;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem 2rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-radius: 0.75rem;
            cursor: pointer;
            font-weight: 700;
            font-size: 1.125rem;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }

        /* Dashboard Content */
        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .header-left h1 {
            font-size: 2rem;
            font-weight: 900;
            margin-bottom: 0.5rem;
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #6b7280;
            font-size: 0.875rem;
        }

        .header-actions {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            font-size: 0.875rem;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: white;
            color: var(--dark);
            border: 1px solid #e5e7eb;
        }

        body.dark-mode .btn-secondary {
            background: #1e293b;
            color: white;
            border-color: #334155;
        }

        .btn-secondary:hover {
            background: #f3f4f6;
        }

        body.dark-mode .btn-secondary:hover {
            background: #334155;
        }

        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: white;
            padding: 1.5rem;
            border-radius: 1rem;
            border: 1px solid #e5e7eb;
            transition: all 0.3s;
        }

        body.dark-mode .stat-card {
            background: #1e293b;
            border-color: #334155;
        }

        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.1);
        }

        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .stat-icon {
            width: 48px;
            height: 48px;
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 900;
            margin-bottom: 0.25rem;
        }

        .stat-label {
            color: #6b7280;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .stat-trend {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.875rem;
            font-weight: 600;
            margin-top: 0.5rem;
        }

        .trend-up {
            color: var(--success);
        }

        .trend-down {
            color: var(--danger);
        }

        /* Chart Section */
        .chart-section {
            margin-bottom: 2rem;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 800;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .section-actions {
            display: flex;
            gap: 0.5rem;
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        body.dark-mode .icon-btn {
            background: #1e293b;
            border-color: #334155;
        }

        .icon-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 1.5rem;
        }

        .chart-card {
            background: white;
            padding: 1.5rem;
            border-radius: 1rem;
            border: 1px solid #e5e7eb;
        }

        body.dark-mode .chart-card {
            background: #1e293b;
            border-color: #334155;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .chart-title {
            font-weight: 700;
            font-size: 1.125rem;
        }

        .chart-container {
            position: relative;
            height: 300px;
        }

        /* Metrics Table */
        .table-container {
            background: white;
            border-radius: 1rem;
            border: 1px solid #e5e7eb;
            overflow: hidden;
            margin-bottom: 2rem;
        }

        body.dark-mode .table-container {
            background: #1e293b;
            border-color: #334155;
        }

        .table-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        body.dark-mode .table-header {
            border-bottom-color: #334155;
        }

        .table-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .search-box {
            position: relative;
        }

        .search-input {
            padding: 0.5rem 1rem 0.5rem 2.5rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            width: 250px;
            background: white;
            color: inherit;
        }

        body.dark-mode .search-input {
            background: #0f172a;
            border-color: #334155;
        }

        .search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: #9ca3af;
        }

        .filter-select {
            padding: 0.5rem 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            background: white;
            color: inherit;
            cursor: pointer;
        }

        body.dark-mode .filter-select {
            background: #0f172a;
            border-color: #334155;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: #f9fafb;
        }

        body.dark-mode thead {
            background: #0f172a;
        }

        th {
            padding: 1rem 1.5rem;
            text-align: left;
            font-weight: 700;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #6b7280;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            background: #f3f4f6;
        }

        body.dark-mode th:hover {
            background: #1e293b;
        }

        td {
            padding: 1rem 1.5rem;
            border-top: 1px solid #e5e7eb;
            font-size: 0.875rem;
        }

        body.dark-mode td {
            border-top-color: #334155;
        }

        tr:hover {
            background: #f9fafb;
        }

        body.dark-mode tr:hover {
            background: #0f172a;
        }

        .metric-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-weight: 600;
            font-size: 0.75rem;
        }

        .badge-success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
        }

        .badge-warning {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning);
        }

        .badge-danger {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            border-bottom: 2px solid #e5e7eb;
            margin-bottom: 2rem;
        }

        body.dark-mode .tabs {
            border-bottom-color: #334155;
        }

        .tab {
            padding: 1rem 1.5rem;
            cursor: pointer;
            font-weight: 600;
            color: #6b7280;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tab:hover {
            color: var(--primary);
        }

        .tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .main-content {
                margin-left: 0;
            }

            .chart-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .navbar {
                padding: 0 1rem;
            }

            .main-content {
                padding: 1rem;
            }

            .dashboard-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .search-input {
                width: 100%;
            }

            .table-controls {
                flex-direction: column;
                width: 100%;
            }
        }

        /* Loading Animation */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e5e7eb;
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tooltips */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #1f2937;
            color: white;
            text-align: center;
            border-radius: 0.5rem;
            padding: 0.5rem;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Settings Panels */
        .settings-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .settings-panel {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 1rem;
            padding: 1.5rem;
            transition: all 0.2s;
        }

        body.dark-mode .settings-panel {
            background: #1e293b;
            border-color: #334155;
        }

        .settings-panel:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .settings-panel-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #e5e7eb;
        }

        body.dark-mode .settings-panel-header {
            border-bottom-color: #334155;
        }

        .settings-panel-icon {
            width: 40px;
            height: 40px;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
        }

        .settings-panel-title {
            font-size: 1.125rem;
            font-weight: 700;
            color: #1f2937;
        }

        body.dark-mode .settings-panel-title {
            color: #f1f5f9;
        }

        .settings-group {
            margin-top: 1rem;
        }

        .settings-label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            color: #374151;
        }

        body.dark-mode .settings-label {
            color: #cbd5e1;
        }

        .settings-input, .settings-select {
            width: 100%;
            padding: 0.625rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            transition: all 0.2s;
            background: white;
            color: #1f2937;
        }

        body.dark-mode .settings-input,
        body.dark-mode .settings-select {
            background: #0f172a;
            border-color: #334155;
            color: #f1f5f9;
        }

        .settings-input:focus,
        .settings-select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .color-picker-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .color-picker {
            width: 50px;
            height: 40px;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-picker:hover {
            transform: scale(1.1);
            border-color: var(--primary);
        }

        .color-label {
            flex: 1;
            font-size: 0.875rem;
        }

        .switch-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 0;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #cbd5e1;
            transition: 0.3s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary);
        }

        input:checked + .slider:before {
            transform: translateX(24px);
        }

        .monitoring-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .monitor-card {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 1rem;
            padding: 1.5rem;
            transition: all 0.3s;
        }

        body.dark-mode .monitor-card {
            background: #1e293b;
            border-color: #334155;
        }

        .monitor-card:hover {
            border-color: var(--primary);
            transform: translateY(-4px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .monitor-icon {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }

        .monitor-label {
            font-size: 0.875rem;
            color: #6b7280;
            margin-bottom: 0.5rem;
        }

        body.dark-mode .monitor-label {
            color: #9ca3af;
        }

        .monitor-value {
            font-size: 2rem;
            font-weight: 700;
            color: #1f2937;
        }

        body.dark-mode .monitor-value {
            color: #f8fafc;
        }

        .monitor-status {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 0.5rem;
        }

        .status-healthy {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
        }

        .status-warning {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning);
        }

        .status-critical {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
        }

        /* Settings Page */
        .settings-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .settings-section {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 1rem;
            padding: 2rem;
            margin-bottom: 1.5rem;
        }

        body.dark-mode .settings-section {
            background: #1e293b;
            border-color: #334155;
        }

        .settings-title {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        body.dark-mode .settings-title {
            color: #f8fafc;
        }

        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid #e5e7eb;
        }

        body.dark-mode .settings-option {
            border-bottom-color: #334155;
        }

        .settings-option:last-child {
            border-bottom: none;
        }

        .option-label {
            flex: 1;
        }

        .option-title {
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 0.25rem;
        }

        body.dark-mode .option-title {
            color: #f8fafc;
        }

        .option-description {
            font-size: 0.875rem;
            color: #6b7280;
        }

        body.dark-mode .option-description {
            color: #9ca3af;
        }

        .option-control {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .color-picker-wrapper {
            position: relative;
        }

        .color-preview {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-preview:hover {
            transform: scale(1.1);
            border-color: var(--primary);
        }

        .color-picker {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }

        .select-custom {
            padding: 0.5rem 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            background: white;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        body.dark-mode .select-custom {
            background: #0f172a;
            border-color: #334155;
            color: #f8fafc;
        }

        .select-custom:hover {
            border-color: var(--primary);
        }

        .select-custom:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Chart Controls */
        .chart-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .control-btn {
            padding: 0.5rem 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            background: white;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        body.dark-mode .control-btn {
            background: #0f172a;
            border-color: #334155;
            color: #f8fafc;
        }

        .control-btn:hover {
            border-color: var(--primary);
            color: var(--primary);
            transform: translateY(-2px);
        }

        .control-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        body.dark-mode .control-btn.active {
            background: var(--primary);
            color: white;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 9999px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        body.dark-mode .progress-bar {
            background: #334155;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            transition: width 0.3s ease;
            border-radius: 9999px;
        }

        /* Color Scheme Presets */
        .color-scheme-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .scheme-card {
            padding: 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        body.dark-mode .scheme-card {
            border-color: #334155;
        }

        .scheme-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .scheme-card.active {
            border-color: var(--primary);
            background: rgba(59, 130, 246, 0.05);
        }

        .scheme-colors {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 0.5rem;
            justify-content: center;
        }

        .scheme-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
        }

        .scheme-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: #6b7280;
        }

        body.dark-mode .scheme-name {
            color: #9ca3af;
        }

        /* Real-time indicator */
        .realtime-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(16, 185, 129, 0.1);
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--success);
        }

        .pulse-dot {
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.2);
            }
        }
        }

        body.dark-mode .monitor-card {
            background: #1e293b;
            border-color: #334155;
        }

        .monitor-card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.1);
        }

        .monitor-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .monitor-icon {
            width: 48px;
            height: 48px;
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .monitor-info h3 {
            font-size: 0.875rem;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 0.25rem;
        }

        .monitor-value {
            font-size: 1.75rem;
            font-weight: 800;
            color: #1f2937;
        }

        body.dark-mode .monitor-value {
            color: #f1f5f9;
        }

        .monitor-progress {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            margin-top: 1rem;
            overflow: hidden;
        }

        body.dark-mode .monitor-progress {
            background: #334155;
        }

        .monitor-progress-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .monitor-details {
            display: flex;
            justify-content: space-between;
            margin-top: 0.75rem;
            font-size: 0.75rem;
            color: #6b7280;
        }

        .chart-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(59, 130, 246, 0.05);
            border-radius: 0.75rem;
        }

        body.dark-mode .chart-controls {
            background: rgba(59, 130, 246, 0.1);
        }

        .chart-control-btn {
            padding: 0.5rem 1rem;
            border: 2px solid #e5e7eb;
            background: white;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: #374151;
        }

        body.dark-mode .chart-control-btn {
            background: #1e293b;
            border-color: #334155;
            color: #cbd5e1;
        }

        .chart-control-btn:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .chart-control-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 5rem;
            right: 1rem;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .toast {
            background: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            min-width: 300px;
            animation: slideIn 0.3s ease-out;
        }

        body.dark-mode .toast {
            background: #1e293b;
        }

        .toast.success {
            border-left: 4px solid var(--success);
        }

        .toast.error {
            border-left: 4px solid var(--danger);
        }

        .toast.warning {
            border-left: 4px solid var(--warning);
        }

        .toast.info {
            border-left: 4px solid var(--info);
        }

        .toast-icon {
            font-size: 1.25rem;
        }

        .toast.success .toast-icon {
            color: var(--success);
        }

        .toast.error .toast-icon {
            color: var(--danger);
        }

        .toast.warning .toast-icon {
            color: var(--warning);
        }

        .toast.info .toast-icon {
            color: var(--info);
        }

        .toast-message {
            flex: 1;
            font-size: 0.875rem;
        }

        .toast-close {
            background: none;
            border: none;
            cursor: pointer;
            color: inherit;
            opacity: 0.5;
            font-size: 1.25rem;
        }

        .toast-close:hover {
            opacity: 1;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Top Navbar -->
    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <button class="menu-toggle" id="menuToggle" onclick="toggleSidebar()">
                    <i class="fas fa-bars"></i>
                </button>
                <div class="logo">
                    <i class="fas fa-chart-line"></i>
                    <span>SynDataGen</span>
                </div>
            </div>
            <div class="nav-right">
                <button class="nav-btn" onclick="refreshExperiment()" title="Atualizar">
                    <i class="fas fa-sync-alt"></i>
                </button>
                <button class="nav-btn" onclick="showNotificationsCenter()" title="Notificações">
                    <i class="fas fa-bell"></i>
                    <span class="nav-badge">3</span>
                </button>
                <button class="nav-btn" onclick="toggleTheme()" title="Alternar Tema">
                    <i class="fas fa-moon" id="themeIcon"></i>
                </button>
                <button class="nav-btn" onclick="showSettings()" title="Configurações">
                    <i class="fas fa-cog"></i>
                </button>
            </div>
        </div>
    </nav>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">
                <i class="fas fa-flask"></i>
                Experimentos
                <span id="totalExperiments" style="margin-left: auto; background: var(--primary); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.7rem;">0</span>
            </div>
            <div class="experiment-list" id="experimentList">
                <!-- Experiments will be populated here -->
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">
                <i class="fas fa-bolt"></i>
                Ações Rápidas
            </div>
            <div class="quick-actions">
                <button class="action-btn" onclick="document.getElementById('fileInput').click()">
                    <i class="fas fa-upload"></i>
                    Carregar Mais JSONs
                </button>
                <button class="action-btn" onclick="exportCurrentExperiment()">
                    <i class="fas fa-download"></i>
                    Exportar CSV
                </button>
                <button class="action-btn" onclick="compareExperiments()">
                    <i class="fas fa-columns"></i>
                    Comparar Experimentos
                </button>
                <button class="action-btn" onclick="generateReport()">
                    <i class="fas fa-file-alt"></i>
                    Gerar Relatório
                </button>
                <button class="action-btn" onclick="exportAllExperiments()">
                    <i class="fas fa-file-archive"></i>
                    Exportar Todos
                </button>
                <button class="action-btn" onclick="resetDashboard()">
                    <i class="fas fa-redo"></i>
                    Limpar Tudo
                </button>
            </div>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content" id="mainContent">
        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <div class="upload-container">
                <div class="upload-icon">
                    <i class="fas fa-cloud-upload-alt"></i>
                </div>
                <h1 class="upload-title">Carregue seus experimentos</h1>
                <p class="upload-subtitle">
                    Arraste e solte um arquivo JSON ou clique para selecionar
                </p>
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" class="file-input" accept=".json" multiple onchange="handleFileUpload(event)">
                    <label for="fileInput" class="file-input-label">
                        <i class="fas fa-folder-open"></i>
                        Selecionar Arquivos JSON
                    </label>
                </div>
                <p style="margin-top: 1rem; color: #6b7280; font-size: 0.875rem;">
                    <i class="fas fa-info-circle"></i> Você pode selecionar múltiplos arquivos
                </p>
            </div>
        </div>

        <!-- Dashboard Content (Hidden by default) -->
        <div id="dashboardContent" style="display: none;">
            <!-- Header -->
            <div class="dashboard-header">
                <div class="header-left">
                    <h1 id="experimentTitle">Dashboard de Experimentos</h1>
                    <div class="breadcrumb">
                        <i class="fas fa-home"></i>
                        <span>/</span>
                        <span id="breadcrumbPath">Dashboard</span>
                    </div>
                </div>
                <div class="header-actions">
                    <button class="btn btn-secondary" onclick="exportAsPDF()">
                        <i class="fas fa-file-pdf"></i>
                        Exportar PDF
                    </button>
                    <button class="btn btn-primary" onclick="shareExperiment()">
                        <i class="fas fa-share-alt"></i>
                        Compartilhar
                    </button>
                </div>
            </div>

            <!-- Tabs -->
            <div class="tabs" id="metricsTabs">
                <div class="tab active" onclick="switchTab('classification')">
                    <i class="fas fa-chart-bar"></i>
                    Classificação
                </div>
                <div class="tab" onclick="switchTab('distance')">
                    <i class="fas fa-ruler"></i>
                    Distâncias
                </div>
                <div class="tab" onclick="switchTab('efficiency')">
                    <i class="fas fa-tachometer-alt"></i>
                    Eficiência
                </div>
                <div class="tab" onclick="switchTab('sdv')">
                    <i class="fas fa-check-circle"></i>
                    SDV Metrics
                </div>
                <div class="tab" onclick="switchTab('arguments')">
                    <i class="fas fa-cog"></i>
                    Argumentos
                </div>
                <div class="tab" onclick="switchTab('monitoring')">
                    <i class="fas fa-desktop"></i>
                    Monitoramento
                </div>
                <div class="tab" onclick="switchTab('settings')">
                    <i class="fas fa-sliders-h"></i>
                    Configurações
                </div>
            </div>

            <!-- Stats Cards -->
            <div class="stats-grid" id="statsGrid">
                <!-- Stats will be populated dynamically -->
            </div>

            <!-- Charts Section -->
            <div class="chart-section">
                <div class="section-header">
                    <h2 class="section-title">
                        <i class="fas fa-chart-area"></i>
                        Visualizações
                    </h2>
                    <div class="section-actions">
                        <button class="icon-btn" onclick="refreshCharts()" title="Atualizar Gráficos">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        <button class="icon-btn" onclick="downloadCharts()" title="Baixar Gráficos">
                            <i class="fas fa-download"></i>
                        </button>
                    </div>
                </div>
                <div class="chart-grid" id="chartsContainer">
                    <!-- Charts will be populated dynamically -->
                </div>
            </div>

            <!-- Metrics Table -->
            <div class="table-container">
                <div class="table-header">
                    <h3 class="section-title">
                        <i class="fas fa-table"></i>
                        Métricas Detalhadas
                    </h3>
                    <div class="table-controls">
                        <div class="search-box">
                            <i class="fas fa-search search-icon"></i>
                            <input type="text" class="search-input" placeholder="Buscar modelo..." onkeyup="filterTable(this.value)">
                        </div>
                        <select class="filter-select" onchange="filterByMetric(this.value)">
                            <option value="all">Todos os Modelos</option>
                            <option value="high">Alta Performance (>70%)</option>
                            <option value="medium">Média Performance (50-70%)</option>
                            <option value="low">Baixa Performance (<50%)</option>
                        </select>
                    </div>
                </div>
                <div style="overflow-x: auto;">
                    <table id="metricsTable">
                        <thead>
                            <tr>
                                <th onclick="sortTable(0)">Modelo <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(1)">Fold <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(2)">Accuracy <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(3)">F1-Score <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(4)">Precision <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(5)">Recall <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(6)">MSE <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(7)">MAE <i class="fas fa-sort"></i></th>
                            </tr>
                        </thead>
                        <tbody id="metricsTableBody">
                            <!-- Table rows will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </main>

<script>
    let allExperiments = {};
    let experimentMetadata = {};
    let currentExperiment = null;
    let currentTab = 'classification';
    let charts = {};
    let isDarkMode = false;
    let isSidebarOpen = true;
    let comparisonMode = false;

    // Chart customization settings
    let chartSettings = {
        colors: {
            primary: '#3b82f6',
            secondary: '#8b5cf6',
            success: '#10b981',
            warning: '#f59e0b',
            danger: '#ef4444',
            info: '#06b6d4'
        },
        chartType: {
            accuracy: 'bar',
            f1: 'bar',
            precision: 'bar',
            recall: 'bar',
            comparison: 'radar'
        },
        showLegend: true,
        showGridLines: true,
        animationEnabled: true,
        animationDuration: 750,
        colorScheme: 'default',
        exportQuality: 'high'
    };

    // Color scheme presets
    const colorSchemes = {
        default: {
            name: 'Padrão',
            colors: ['#3b82f6', '#8b5cf6', '#10b981', '#f59e0b', '#ef4444', '#06b6d4', '#ec4899']
        },
        ocean: {
            name: 'Oceano',
            colors: ['#0891b2', '#06b6d4', '#22d3ee', '#67e8f9', '#0284c7', '#0369a1', '#075985']
        },
        forest: {
            name: 'Floresta',
            colors: ['#10b981', '#059669', '#34d399', '#6ee7b7', '#047857', '#065f46', '#064e3b']
        },
        sunset: {
            name: 'Pôr do Sol',
            colors: ['#f59e0b', '#f97316', '#fb923c', '#fdba74', '#ea580c', '#c2410c', '#9a3412']
        },
        purple: {
            name: 'Roxo',
            colors: ['#8b5cf6', '#a78bfa', '#c4b5fd', '#7c3aed', '#6d28d9', '#5b21b6', '#4c1d95']
        },
        vivid: {
            name: 'Vibrante',
            colors: ['#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6', '#ec4899', '#06b6d4']
        },
        monochrome: {
            name: 'Monocromático',
            colors: ['#1f2937', '#374151', '#4b5563', '#6b7280', '#9ca3af', '#d1d5db', '#e5e7eb']
        },
        pastel: {
            name: 'Pastel',
            colors: ['#93c5fd', '#c4b5fd', '#a7f3d0', '#fcd34d', '#fca5a5', '#bfdbfe', '#f9a8d4']
        }
    };

    // System monitoring variables
    let monitoringInterval = null;
    let systemStats = {
        cpu: 0,
        memory: 0,
        performance: 0,
        fps: 0,
        latency: 0
    };
        animationDuration: 750
    };

    // System monitoring variables
    let systemMonitoring = {
        enabled: false,
        refreshInterval: 5000,
        intervalId: null
    };

    // Helper function to extract value (handles both direct values and {mean, std} objects)
    function getValue(val, defaultValue = 0) {
        if (val === null || val === undefined) return defaultValue;
        if (typeof val === 'object' && val.mean !== undefined) {
            return val.mean;
        }
        return val;
    }

    // Handle file upload
    function handleFileUpload(event) {
        const files = event.target.files;
        console.log('Files selected:', files.length);
        if (!files || files.length === 0) return;

        let filesProcessed = 0;
        let filesWithErrors = [];
        const totalFiles = files.length;

        Array.from(files).forEach(file => {
            console.log('Processing file:', file.name);
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    console.log('Parsing JSON for:', file.name);
                    const data = JSON.parse(e.target.result);
                    let experimentName = file.name.replace('.json', '');
                    
                    // Check if experiment already exists
                    if (allExperiments[experimentName]) {
                        const timestamp = new Date().getTime();
                        experimentName = `${experimentName}_${timestamp}`;
                    }
                    
                    console.log('Storing experiment:', experimentName);
                    // Store experiment
                    allExperiments[experimentName] = data;
                    
                    // Extract metadata
                    experimentMetadata[experimentName] = {
                        modelType: data.Arguments?.model_type || 'unknown',
                        numFolds: extractNumFolds(data),
                        timestamp: new Date().toISOString(),
                        originalName: file.name.replace('.json', '')
                    };
                    
                    console.log('Adding to sidebar:', experimentName);
                    // Add to sidebar
                    addExperimentToSidebar(experimentName);
                    
                    filesProcessed++;
                    console.log(`Files processed: ${filesProcessed}/${totalFiles}`);
                    
                    // After all files are processed
                    if (filesProcessed === totalFiles) {
                        console.log('All files processed, showing dashboard');
                        // Update counter
                        document.getElementById('totalExperiments').textContent = Object.keys(allExperiments).length;
                        
                        // Show dashboard
                        document.getElementById('uploadSection').style.display = 'none';
                        document.getElementById('dashboardContent').style.display = 'block';
                        
                        // Select the first experiment if none selected
                        if (!currentExperiment) {
                            const firstExperiment = Object.keys(allExperiments)[0];
                            console.log('Selecting first experiment:', firstExperiment);
                            if (firstExperiment) {
                                selectExperiment(firstExperiment);
                            }
                        }
                        
                        if (filesWithErrors.length > 0) {
                            showNotification(`${filesProcessed - filesWithErrors.length} arquivo(s) carregado(s). ${filesWithErrors.length} com erro.`, 'warning');
                        } else {
                            showNotification(`${filesProcessed} arquivo(s) carregado(s) com sucesso!`, 'success');
                        }
                    }
                    
                } catch (error) {
                    console.error(`Erro ao carregar ${file.name}:`, error);
                    filesWithErrors.push(file.name);
                    filesProcessed++;
                    
                    if (filesProcessed === totalFiles) {
                        if (filesWithErrors.length === totalFiles) {
                            showNotification('Erro ao carregar todos os arquivos. Verifique o formato.', 'error');
                        } else {
                            document.getElementById('uploadSection').style.display = 'none';
                            document.getElementById('dashboardContent').style.display = 'block';
                            document.getElementById('totalExperiments').textContent = Object.keys(allExperiments).length;
                            
                            if (!currentExperiment && Object.keys(allExperiments).length > 0) {
                                selectExperiment(Object.keys(allExperiments)[0]);
                            }
                            
                            showNotification(`${filesProcessed - filesWithErrors.length} arquivo(s) carregado(s). ${filesWithErrors.length} com erro.`, 'warning');
                        }
                    }
                }
            };
            
            reader.onerror = function() {
                console.error(`Erro ao ler arquivo ${file.name}`);
                filesWithErrors.push(file.name);
                filesProcessed++;
                
                if (filesProcessed === totalFiles) {
                    if (filesWithErrors.length === totalFiles) {
                        showNotification('Erro ao ler todos os arquivos', 'error');
                    } else {
                        document.getElementById('uploadSection').style.display = 'none';
                        document.getElementById('dashboardContent').style.display = 'block';
                        showNotification(`${filesProcessed - filesWithErrors.length} arquivo(s) carregado(s)`, 'success');
                    }
                }
            };
            
            reader.readAsText(file);
        });
        
        // Clear the file input so the same file can be selected again
        event.target.value = '';
    }

    function extractNumFolds(data) {
        // Try ClassificationMetrics first
        if (data.ClassificationMetrics) {
            const models = Object.values(data.ClassificationMetrics);
            if (models.length > 0) {
                const folds = Object.keys(models[0]).filter(k => k.includes('Fold') && !k.includes('Summary'));
                return folds.length;
            }
        }
        
        // Try EfficiencyMetrics
        if (data.EfficiencyMetrics) {
            const folds = Object.keys(data.EfficiencyMetrics).filter(k => k.includes('Fold') && !k.includes('Summary'));
            return folds.length;
        }
        
        // Try Arguments
        if (data.Arguments && data.Arguments.number_k_folds) {
            return data.Arguments.number_k_folds;
        }
        
        return 0;
    }

    function addExperimentToSidebar(name) {
        console.log('Adding experiment to sidebar:', name);
        const list = document.getElementById('experimentList');
        const metadata = experimentMetadata[name];
        console.log('Metadata:', metadata);
        
        const item = document.createElement('div');
        item.className = 'experiment-item';
        item.dataset.experimentName = name;
        
        // Main content (clickable)
        const mainContent = document.createElement('div');
        mainContent.style.flex = '1';
        mainContent.onclick = () => selectExperiment(name);
        mainContent.innerHTML = `
            <div class="experiment-name">
                <i class="fas fa-database"></i>
                ${metadata.originalName || name}
            </div>
            <div class="experiment-meta">
                <span class="meta-badge">
                    <i class="fas fa-layer-group"></i>
                    ${metadata.modelType}
                </span>
                <span class="meta-badge">
                    <i class="fas fa-folder"></i>
                    ${metadata.numFolds} Folds
                </span>
            </div>
        `;
        
        // Actions (not clickable for selection)
        const actions = document.createElement('div');
        actions.className = 'experiment-actions';
        actions.style.cssText = 'display: flex; gap: 0.25rem; margin-top: 0.5rem;';
        actions.innerHTML = `
            <button class="experiment-action-btn" onclick="event.stopPropagation(); removeExperiment('${name}')" title="Remover">
                <i class="fas fa-trash"></i>
            </button>
            <button class="experiment-action-btn" onclick="event.stopPropagation(); duplicateExperiment('${name}')" title="Duplicar">
                <i class="fas fa-copy"></i>
            </button>
            <button class="experiment-action-btn" onclick="event.stopPropagation(); downloadExperiment('${name}')" title="Baixar">
                <i class="fas fa-download"></i>
            </button>
        `;
        
        item.appendChild(mainContent);
        item.appendChild(actions);
        list.appendChild(item);
        console.log('Experiment added to sidebar successfully');
    }

    function selectExperiment(name) {
        console.log('Selecting experiment:', name);
        currentExperiment = name;
        
        // Update active state
        document.querySelectorAll('.experiment-item').forEach(item => {
            item.classList.remove('active');
            if (item.dataset.experimentName === name) {
                item.classList.add('active');
            }
        });

        // Update breadcrumb
        const displayName = experimentMetadata[name]?.originalName || name;
        document.getElementById('experimentTitle').textContent = displayName;
        document.getElementById('breadcrumbPath').textContent = `Dashboard / ${displayName}`;

        console.log('Rendering dashboard for:', name);
        // Render dashboard
        renderDashboard();
    }

    function removeExperiment(name) {
        if (confirm(`Deseja remover o experimento "${experimentMetadata[name]?.originalName || name}"?`)) {
            // Remove from data structures
            delete allExperiments[name];
            delete experimentMetadata[name];
            
            // Remove from sidebar
            const item = document.querySelector(`.experiment-item[data-experiment-name="${name}"]`);
            if (item) {
                item.remove();
            }
            
            // Update counter
            document.getElementById('totalExperiments').textContent = Object.keys(allExperiments).length;
            
            // If it was the current experiment, select another or show upload section
            if (currentExperiment === name) {
                const remainingExperiments = Object.keys(allExperiments);
                if (remainingExperiments.length > 0) {
                    selectExperiment(remainingExperiments[0]);
                } else {
                    currentExperiment = null;
                    document.getElementById('uploadSection').style.display = 'block';
                    document.getElementById('dashboardContent').style.display = 'none';
                }
            }
            
            showNotification('Experimento removido com sucesso', 'success');
        }
    }

    function duplicateExperiment(name) {
        const timestamp = new Date().getTime();
        const newName = `${name}_copy_${timestamp}`;
        
        // Deep clone the data
        allExperiments[newName] = JSON.parse(JSON.stringify(allExperiments[name]));
        
        // Clone metadata
        experimentMetadata[newName] = {
            ...experimentMetadata[name],
            originalName: (experimentMetadata[name]?.originalName || name) + ' (cópia)',
            timestamp: new Date().toISOString()
        };
        
        // Add to sidebar
        addExperimentToSidebar(newName);
        
        // Update counter
        document.getElementById('totalExperiments').textContent = Object.keys(allExperiments).length;
        
        // Select the new experiment
        selectExperiment(newName);
        
        showNotification('Experimento duplicado com sucesso', 'success');
    }

    function downloadExperiment(name) {
        const data = allExperiments[name];
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${experimentMetadata[name]?.originalName || name}.json`;
        a.click();
        window.URL.revokeObjectURL(url);
        
        showNotification('Download iniciado', 'success');
    }

    function showNotification(message, type = 'info') {
        const container = document.getElementById('toastContainer');
        
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icons = {
            success: 'fa-check-circle',
            error: 'fa-exclamation-circle',
            warning: 'fa-exclamation-triangle',
            info: 'fa-info-circle'
        };
        
        toast.innerHTML = `
            <i class="fas ${icons[type]} toast-icon"></i>
            <span class="toast-message">${message}</span>
            <button class="toast-close" onclick="this.parentElement.remove()">
                <i class="fas fa-times"></i>
            </button>
        `;
        
        container.appendChild(toast);
        
        // Auto remove after 5 seconds
        setTimeout(() => {
            toast.remove();
        }, 5000);
    }

    function switchTab(tabName) {
        currentTab = tabName;
        
        // Update active tab
        document.querySelectorAll('.tab').forEach(tab => {
            tab.classList.remove('active');
        });
        event.target.closest('.tab').classList.add('active');

        // Re-render dashboard based on tab
        renderDashboard();
    }

    function renderDashboard() {
        console.log('renderDashboard called for:', currentExperiment, 'tab:', currentTab);
        if (!currentExperiment && currentTab !== 'monitoring' && currentTab !== 'settings') {
            console.warn('No current experiment selected');
            return;
        }

        const data = currentExperiment ? allExperiments[currentExperiment] : null;
        if (currentExperiment) {
            console.log('Experiment data:', data);
        }
        
        switch(currentTab) {
            case 'classification':
                console.log('Rendering classification metrics');
                renderClassificationMetrics(data);
                break;
            case 'distance':
                console.log('Rendering distance metrics');
                renderDistanceMetrics(data);
                break;
            case 'efficiency':
                console.log('Rendering efficiency metrics');
                renderEfficiencyMetrics(data);
                break;
            case 'sdv':
                console.log('Rendering SDV metrics');
                renderSDVMetrics(data);
                break;
            case 'arguments':
                console.log('Rendering arguments');
                renderArguments(data);
                break;
            case 'monitoring':
                console.log('Rendering system monitoring');
                renderSystemMonitoring();
                break;
            case 'settings':
                console.log('Rendering settings');
                renderSettings();
                break;
        }
    }

    function renderClassificationMetrics(data) {
        // Check for classification data in various evaluation sections
        const evaluationSections = ['TS-TR', 'TR-TS', 'TR-TR'];
        let classificationData = null;
        
        // Try to find data in evaluation sections first
        for (const section of evaluationSections) {
            if (data[section]) {
                classificationData = data[section];
                break;
            }
        }
        
        // Fallback to ClassificationMetrics if it exists
        if (!classificationData && data.ClassificationMetrics) {
            classificationData = data.ClassificationMetrics;
        }
        
        if (!classificationData) {
            showNoDataMessage();
            return;
        }

        // Render stats cards
        renderClassificationStats(classificationData);
        
        // Render charts
        renderClassificationCharts(classificationData);
        
        // Render table with all evaluation sections
        renderClassificationTable(data);
    }

    function renderClassificationStats(metrics) {
        const statsGrid = document.getElementById('statsGrid');
        statsGrid.innerHTML = '';

        // Calculate overall statistics
        let totalModels = 0;
        let avgAccuracy = 0;
        let avgF1 = 0;
        let bestModel = '';
        let bestAccuracy = 0;

        Object.entries(metrics).forEach(([modelName, folds]) => {
            totalModels++;
            const summary = folds.Summary;
            if (summary && summary.Accuracy) {
                // Handle both direct value and {mean, std} structure
                const acc = (typeof summary.Accuracy === 'object' ? summary.Accuracy.mean : summary.Accuracy) * 100;
                const f1 = (typeof summary.F1Score === 'object' ? summary.F1Score.mean : summary.F1Score || 0) * 100;
                
                avgAccuracy += acc;
                avgF1 += f1;
                
                if (acc > bestAccuracy) {
                    bestAccuracy = acc;
                    bestModel = modelName;
                }
            }
        });

        avgAccuracy /= totalModels;
        avgF1 /= totalModels;

        const stats = [
            {
                icon: 'fa-brain',
                label: 'Total de Modelos',
                value: totalModels,
                color: 'var(--primary)',
                trend: null
            },
            {
                icon: 'fa-percentage',
                label: 'Accuracy Média',
                value: avgAccuracy.toFixed(2) + '%',
                color: 'var(--success)',
                trend: { value: '+2.5%', up: true }
            },
            {
                icon: 'fa-chart-line',
                label: 'F1-Score Médio',
                value: avgF1.toFixed(2) + '%',
                color: 'var(--info)',
                trend: { value: '+1.8%', up: true }
            },
            {
                icon: 'fa-trophy',
                label: 'Melhor Modelo',
                value: bestModel,
                subvalue: bestAccuracy.toFixed(2) + '%',
                color: 'var(--warning)',
                trend: null
            }
        ];

        stats.forEach(stat => {
            const card = document.createElement('div');
            card.className = 'stat-card';
            card.innerHTML = `
                <div class="stat-header">
                    <div class="stat-icon" style="background: ${stat.color}20; color: ${stat.color};">
                        <i class="fas ${stat.icon}"></i>
                    </div>
                </div>
                <div class="stat-value">${stat.value}</div>
                ${stat.subvalue ? `<div class="stat-label">${stat.subvalue}</div>` : ''}
                <div class="stat-label">${stat.label}</div>
                ${stat.trend ? `
                    <div class="stat-trend ${stat.trend.up ? 'trend-up' : 'trend-down'}">
                        <i class="fas fa-arrow-${stat.trend.up ? 'up' : 'down'}"></i>
                        ${stat.trend.value}
                    </div>
                ` : ''}
            `;
            statsGrid.appendChild(card);
        });
    }

    function renderClassificationCharts(metrics) {
        const container = document.getElementById('chartsContainer');
        container.innerHTML = '';

        // Destroy existing charts
        Object.values(charts).forEach(chart => chart?.destroy());
        charts = {};

        // Prepare data for charts
        const chartData = prepareClassificationChartData(metrics);

        // Create chart cards
        const chartConfigs = [
            {
                id: 'accuracyChart',
                title: 'Accuracy por Modelo',
                type: 'bar',
                data: chartData.accuracy,
                color: 'rgba(59, 130, 246, 0.8)'
            },
            {
                id: 'f1Chart',
                title: 'F1-Score por Modelo',
                type: 'bar',
                data: chartData.f1,
                color: 'rgba(16, 185, 129, 0.8)'
            },
            {
                id: 'precisionRecallChart',
                title: 'Precision vs Recall',
                type: 'radar',
                data: [chartData.precision, chartData.recall],
                labels: ['Precision', 'Recall']
            },
            {
                id: 'errorChart',
                title: 'Métricas de Erro',
                type: 'bar',
                data: [chartData.mse, chartData.mae],
                labels: ['MSE', 'MAE']
            }
        ];

        chartConfigs.forEach(config => {
            const card = document.createElement('div');
            card.className = 'chart-card';
            card.innerHTML = `
                <div class="chart-header">
                    <h3 class="chart-title">${config.title}</h3>
                </div>
                <div class="chart-container">
                    <canvas id="${config.id}"></canvas>
                </div>
            `;
            container.appendChild(card);

            // Add chart controls
            if (config.id !== 'precisionRecallChart' && config.id !== 'errorChart') {
                const chartName = config.id.replace('Chart', '');
                setTimeout(() => addChartControls(card, chartName), 150);
            }
        });

        // Create charts
        setTimeout(() => createClassificationCharts(chartData), 100);
    }

    function prepareClassificationChartData(metrics) {
        const labels = [];
        const accuracy = [];
        const f1 = [];
        const precision = [];
        const recall = [];
        const mse = [];
        const mae = [];

        Object.entries(metrics).forEach(([modelName, folds]) => {
            const summary = folds.Summary;
            if (summary) {
                labels.push(modelName);
                accuracy.push((getValue(summary.Accuracy) * 100).toFixed(2));
                f1.push((getValue(summary.F1Score) * 100).toFixed(2));
                precision.push((getValue(summary.Precision) * 100).toFixed(2));
                recall.push((getValue(summary.Recall) * 100).toFixed(2));
                mse.push(getValue(summary.MeanSquareError).toFixed(4));
                mae.push(getValue(summary.MeanAbsoluteError).toFixed(4));
            }
        });

        return { labels, accuracy, f1, precision, recall, mse, mae };
    }

    function createClassificationCharts(chartData) {
        const isDark = document.body.classList.contains('dark-mode');
        const textColor = isDark ? '#f1f5f9' : '#0f172a';
        const gridColor = isDark ? '#334155' : '#e5e7eb';

        // Helper function to convert hex to rgba
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Accuracy Chart
        charts.accuracy = new Chart(document.getElementById('accuracyChart'), {
            type: chartSettings.chartType.accuracy || 'bar',
            data: {
                labels: chartData.labels,
                datasets: [{
                    label: 'Accuracy (%)',
                    data: chartData.accuracy,
                    backgroundColor: hexToRgba(chartSettings.colors.primary, 0.8),
                    borderColor: chartSettings.colors.primary,
                    borderWidth: 2,
                    borderRadius: chartSettings.chartType.accuracy === 'bar' ? 8 : 0,
                    tension: chartSettings.chartType.accuracy === 'line' ? 0.4 : 0,
                    fill: chartSettings.chartType.accuracy === 'line' ? true : false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: chartSettings.animationEnabled ? chartSettings.animationDuration : 0
                },
                plugins: {
                    legend: { 
                        display: chartSettings.showLegend,
                        labels: { color: textColor }
                    },
                    tooltip: {
                        backgroundColor: isDark ? '#1e293b' : '#ffffff',
                        titleColor: isDark ? '#f1f5f9' : '#0f172a',
                        bodyColor: isDark ? '#f1f5f9' : '#0f172a',
                        borderColor: gridColor,
                        borderWidth: 1
                    }
                },
                scales: chartSettings.chartType.accuracy !== 'radar' ? {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        grid: { 
                            display: chartSettings.showGridLines,
                            color: gridColor 
                        },
                        ticks: { color: textColor }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: textColor }
                    }
                } : {
                    r: {
                        beginAtZero: true,
                        max: 100,
                        grid: { color: gridColor },
                        ticks: { color: textColor },
                        pointLabels: { color: textColor }
                    }
                }
            }
        });

        // F1-Score Chart
        charts.f1 = new Chart(document.getElementById('f1Chart'), {
            type: chartSettings.chartType.f1 || 'bar',
            data: {
                labels: chartData.labels,
                datasets: [{
                    label: 'F1-Score (%)',
                    data: chartData.f1,
                    backgroundColor: hexToRgba(chartSettings.colors.success, 0.8),
                    borderColor: chartSettings.colors.success,
                    borderWidth: 2,
                    borderRadius: chartSettings.chartType.f1 === 'bar' ? 8 : 0,
                    tension: chartSettings.chartType.f1 === 'line' ? 0.4 : 0,
                    fill: chartSettings.chartType.f1 === 'line' ? true : false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: chartSettings.animationEnabled ? chartSettings.animationDuration : 0
                },
                plugins: {
                    legend: { 
                        display: chartSettings.showLegend,
                        labels: { color: textColor }
                    },
                    tooltip: {
                        backgroundColor: isDark ? '#1e293b' : '#ffffff',
                        titleColor: isDark ? '#f1f5f9' : '#0f172a',
                        bodyColor: isDark ? '#f1f5f9' : '#0f172a',
                        borderColor: gridColor,
                        borderWidth: 1
                    }
                },
                scales: chartSettings.chartType.f1 !== 'radar' ? {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        grid: { 
                            display: chartSettings.showGridLines,
                            color: gridColor 
                        },
                        ticks: { color: textColor }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: textColor }
                    }
                } : {
                    r: {
                        beginAtZero: true,
                        max: 100,
                        grid: { color: gridColor },
                        ticks: { color: textColor },
                        pointLabels: { color: textColor }
                    }
                }
            }
        });

        // Precision vs Recall Radar Chart
        charts.radar = new Chart(document.getElementById('precisionRecallChart'), {
            type: chartSettings.chartType.comparison || 'radar',
            data: {
                labels: chartData.labels,
                datasets: [
                    {
                        label: 'Precision',
                        data: chartData.precision,
                        backgroundColor: hexToRgba(chartSettings.colors.secondary, 0.2),
                        borderColor: chartSettings.colors.secondary,
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true
                    },
                    {
                        label: 'Recall',
                        data: chartData.recall,
                        backgroundColor: hexToRgba(chartSettings.colors.info, 0.2),
                        borderColor: chartSettings.colors.info,
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: chartSettings.animationEnabled ? chartSettings.animationDuration : 0
                },
                plugins: {
                    legend: { 
                        display: chartSettings.showLegend,
                        labels: { color: textColor }
                    }
                },
                scales: chartSettings.chartType.comparison === 'radar' ? {
                    r: {
                        beginAtZero: true,
                        max: 100,
                        grid: { 
                            display: chartSettings.showGridLines,
                            color: gridColor 
                        },
                        ticks: { color: textColor },
                        pointLabels: { color: textColor }
                    }
                } : {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        grid: { 
                            display: chartSettings.showGridLines,
                            color: gridColor 
                        },
                        ticks: { color: textColor }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: textColor }
                    }
                }
            }
        });

        // Error Chart
        charts.error = new Chart(document.getElementById('errorChart'), {
            type: 'bar',
            data: {
                labels: chartData.labels,
                datasets: [
                    {
                        label: 'MSE',
                        data: chartData.mse,
                        backgroundColor: hexToRgba(chartSettings.colors.danger, 0.8),
                        borderColor: chartSettings.colors.danger,
                        borderWidth: 2,
                        borderRadius: 8
                    },
                    {
                        label: 'MAE',
                        data: chartData.mae,
                        backgroundColor: hexToRgba(chartSettings.colors.warning, 0.8),
                        borderColor: chartSettings.colors.warning,
                        borderWidth: 2,
                        borderRadius: 8
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: chartSettings.animationEnabled ? chartSettings.animationDuration : 0
                },
                plugins: {
                    legend: { 
                        display: chartSettings.showLegend,
                        labels: { color: textColor }
                    },
                    tooltip: {
                        backgroundColor: isDark ? '#1e293b' : '#ffffff',
                        titleColor: isDark ? '#f1f5f9' : '#0f172a',
                        bodyColor: isDark ? '#f1f5f9' : '#0f172a',
                        borderColor: gridColor,
                        borderWidth: 1
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: { 
                            display: chartSettings.showGridLines,
                            color: gridColor 
                        },
                        ticks: { color: textColor }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: textColor }
                    }
                }
            }
        });
    }
    }

    function renderClassificationTable(data) {
        const tbody = document.getElementById('metricsTableBody');
        tbody.innerHTML = '';

        // Define evaluation sections to check
        const evaluationSections = ['TS-TR', 'TR-TS', 'TR-TR'];
        
        // Check if we have ClassificationMetrics (old format) or evaluation sections (new format)
        let hasOldFormat = data.ClassificationMetrics;
        let hasNewFormat = evaluationSections.some(section => data[section]);

        if (hasNewFormat) {
            // New format: iterate through evaluation sections
            evaluationSections.forEach(evalSection => {
                if (!data[evalSection]) return;
                
                const metrics = data[evalSection];
                
                Object.entries(metrics).forEach(([modelName, folds]) => {
                    Object.entries(folds).forEach(([fold, foldData]) => {
                        if (fold === 'Summary') {
                            // Show summary as separate row
                            const row = document.createElement('tr');
                            row.style.fontWeight = 'bold';
                            row.style.background = isDarkMode ? '#0f172a' : '#f9fafb';
                            
                            const accuracy = getValue(foldData.Accuracy) * 100;
                            const badge = accuracy >= 70 ? 'badge-success' : accuracy >= 50 ? 'badge-warning' : 'badge-danger';
                            
                            row.innerHTML = `
                                <td>${evalSection} - ${modelName}</td>
                                <td>Média (Summary)</td>
                                <td><span class="metric-badge ${badge}">${accuracy.toFixed(2)}%</span></td>
                                <td>${(getValue(foldData.F1Score) * 100).toFixed(2)}%</td>
                                <td>${(getValue(foldData.Precision) * 100).toFixed(2)}%</td>
                                <td>${(getValue(foldData.Recall) * 100).toFixed(2)}%</td>
                                <td>${getValue(foldData.MeanSquareError).toFixed(4)}</td>
                                <td>${getValue(foldData.MeanAbsoluteError).toFixed(4)}</td>
                            `;
                            tbody.appendChild(row);
                        } else if (fold.includes('Fold')) {
                            const row = document.createElement('tr');
                            
                            const accuracy = getValue(foldData.Accuracy) * 100;
                            const badge = accuracy >= 70 ? 'badge-success' : accuracy >= 50 ? 'badge-warning' : 'badge-danger';
                            
                            row.innerHTML = `
                                <td>${evalSection} - ${modelName}</td>
                                <td>${fold}</td>
                                <td><span class="metric-badge ${badge}">${accuracy.toFixed(2)}%</span></td>
                                <td>${(getValue(foldData.F1Score) * 100).toFixed(2)}%</td>
                                <td>${(getValue(foldData.Precision) * 100).toFixed(2)}%</td>
                                <td>${(getValue(foldData.Recall) * 100).toFixed(2)}%</td>
                                <td>${getValue(foldData.MeanSquareError).toFixed(4)}</td>
                                <td>${getValue(foldData.MeanAbsoluteError).toFixed(4)}</td>
                            `;
                            tbody.appendChild(row);
                        }
                    });
                });
            });
        } else if (hasOldFormat) {
            // Old format: use ClassificationMetrics directly
            const metrics = data.ClassificationMetrics;
            
            Object.entries(metrics).forEach(([modelName, folds]) => {
                Object.entries(folds).forEach(([fold, foldData]) => {
                    if (fold === 'Summary') {
                        // Show summary as separate row
                        const row = document.createElement('tr');
                        row.style.fontWeight = 'bold';
                        row.style.background = isDarkMode ? '#0f172a' : '#f9fafb';
                        
                        const accuracy = getValue(foldData.Accuracy) * 100;
                        const badge = accuracy >= 70 ? 'badge-success' : accuracy >= 50 ? 'badge-warning' : 'badge-danger';
                        
                        row.innerHTML = `
                            <td>${modelName}</td>
                            <td>Média (Summary)</td>
                            <td><span class="metric-badge ${badge}">${accuracy.toFixed(2)}%</span></td>
                            <td>${(getValue(foldData.F1Score) * 100).toFixed(2)}%</td>
                            <td>${(getValue(foldData.Precision) * 100).toFixed(2)}%</td>
                            <td>${(getValue(foldData.Recall) * 100).toFixed(2)}%</td>
                            <td>${getValue(foldData.MeanSquareError).toFixed(4)}</td>
                            <td>${getValue(foldData.MeanAbsoluteError).toFixed(4)}</td>
                        `;
                        tbody.appendChild(row);
                    } else if (fold.includes('Fold')) {
                        const row = document.createElement('tr');
                        
                        const accuracy = getValue(foldData.Accuracy) * 100;
                        const badge = accuracy >= 70 ? 'badge-success' : accuracy >= 50 ? 'badge-warning' : 'badge-danger';
                        
                        row.innerHTML = `
                            <td>${modelName}</td>
                            <td>${fold}</td>
                            <td><span class="metric-badge ${badge}">${accuracy.toFixed(2)}%</span></td>
                            <td>${(getValue(foldData.F1Score) * 100).toFixed(2)}%</td>
                            <td>${(getValue(foldData.Precision) * 100).toFixed(2)}%</td>
                            <td>${(getValue(foldData.Recall) * 100).toFixed(2)}%</td>
                            <td>${getValue(foldData.MeanSquareError).toFixed(4)}</td>
                            <td>${getValue(foldData.MeanAbsoluteError).toFixed(4)}</td>
                        `;
                        tbody.appendChild(row);
                    }
                });
            });
        }
    }

    function renderDistanceMetrics(data) {
        if (!data.DistanceMetrics) {
            showNoDataMessage();
            return;
        }

        const metrics = data.DistanceMetrics;
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        
        // Clear previous content
        statsGrid.innerHTML = '';
        container.innerHTML = '';
        tbody.innerHTML = '';

        // Render stats - get averages from Summary of each comparison type
        const distanceTypes = ['EuclideanDistance', 'HellingerDistance', 'ManhattanDistance', 'HammingDistance', 'JaccardDistance'];
        const comparisonTypes = Object.keys(metrics); // S-S, S-R, R-S, R-R
        
        // Create stats for the first few distance metrics from first comparison type
        const firstType = comparisonTypes[0];
        if (metrics[firstType] && metrics[firstType].Summary) {
            const stats = [];
            const colors = ['var(--primary)', 'var(--success)', 'var(--warning)', 'var(--info)'];
            const icons = ['fa-ruler', 'fa-ruler-horizontal', 'fa-ruler-vertical', 'fa-ruler-combined'];
            
            distanceTypes.slice(0, 4).forEach((distType, i) => {
                if (metrics[firstType].Summary[distType]) {
                    stats.push({
                        icon: icons[i],
                        label: `${firstType} - ${distType}`,
                        value: getValue(metrics[firstType].Summary[distType]).toFixed(4),
                        color: colors[i]
                    });
                }
            });

            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <div class="stat-header">
                        <div class="stat-icon" style="background: ${stat.color}20; color: ${stat.color};">
                            <i class="fas ${stat.icon}"></i>
                        </div>
                    </div>
                    <div class="stat-value">${stat.value}</div>
                    <div class="stat-label">${stat.label}</div>
                `;
                statsGrid.appendChild(card);
            });
        }

        // Render charts - one chart per comparison type
        comparisonTypes.forEach(compType => {
            const chartCard = document.createElement('div');
            chartCard.className = 'chart-card';
            chartCard.innerHTML = `
                <div class="chart-header">
                    <h3 class="chart-title">Distâncias - ${compType}</h3>
                </div>
                <div class="chart-container">
                    <canvas id="distanceChart_${compType}"></canvas>
                </div>
            `;
            container.appendChild(chartCard);
        });

        // Create charts
        setTimeout(() => {
            const isDark = document.body.classList.contains('dark-mode');
            const textColor = isDark ? '#f1f5f9' : '#0f172a';
            const gridColor = isDark ? '#334155' : '#e5e7eb';

            comparisonTypes.forEach(compType => {
                const compData = metrics[compType];
                if (!compData) return;

                const labels = [];
                const datasets = {};

                // Collect fold data
                Object.entries(compData).forEach(([fold, foldData]) => {
                    if (fold !== 'Summary' && foldData) {
                        labels.push(fold);
                        
                        distanceTypes.forEach(distType => {
                            if (!datasets[distType]) {
                                datasets[distType] = [];
                            }
                            datasets[distType].push(getValue(foldData[distType]).toFixed(4));
                        });
                    }
                });

                const colors = [
                    'rgba(59, 130, 246, 0.8)',
                    'rgba(16, 185, 129, 0.8)',
                    'rgba(245, 158, 11, 0.8)',
                    'rgba(239, 68, 68, 0.8)',
                    'rgba(139, 92, 246, 0.8)'
                ];

                const chartDatasets = Object.entries(datasets).map(([name, data], i) => ({
                    label: name,
                    data: data,
                    backgroundColor: colors[i],
                    borderColor: colors[i].replace('0.8', '1'),
                    borderWidth: 2,
                    borderRadius: 8
                }));

                charts[`distance_${compType}`] = new Chart(document.getElementById(`distanceChart_${compType}`), {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: chartDatasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: textColor } }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                grid: { color: gridColor },
                                ticks: { color: textColor }
                            },
                            x: {
                                grid: { display: false },
                                ticks: { color: textColor }
                            }
                        }
                    }
                });
            });
        }, 100);

        // Render table
        const thead = document.querySelector('#metricsTable thead tr');
        thead.innerHTML = `
            <th>Tipo de Comparação</th>
            <th>Fold</th>
            <th>Euclidean</th>
            <th>Hellinger</th>
            <th>Manhattan</th>
            <th>Hamming</th>
            <th>Jaccard</th>
        `;

        Object.entries(metrics).forEach(([compType, folds]) => {
            Object.entries(folds).forEach(([fold, data]) => {
                if (data && typeof data === 'object') {
                    const row = document.createElement('tr');
                    if (fold === 'Summary') {
                        row.style.fontWeight = 'bold';
                        row.style.background = isDarkMode ? '#0f172a' : '#f9fafb';
                    }
                    
                    row.innerHTML = `
                        <td>${compType}</td>
                        <td>${fold === 'Summary' ? 'Média (Summary)' : fold}</td>
                        <td>${getValue(data.EuclideanDistance, 'N/A') !== 'N/A' ? getValue(data.EuclideanDistance).toFixed(4) : 'N/A'}</td>
                        <td>${getValue(data.HellingerDistance, 'N/A') !== 'N/A' ? getValue(data.HellingerDistance).toFixed(4) : 'N/A'}</td>
                        <td>${getValue(data.ManhattanDistance, 'N/A') !== 'N/A' ? getValue(data.ManhattanDistance).toFixed(4) : 'N/A'}</td>
                        <td>${getValue(data.HammingDistance, 'N/A') !== 'N/A' ? getValue(data.HammingDistance).toFixed(4) : 'N/A'}</td>
                        <td>${getValue(data.JaccardDistance, 'N/A') !== 'N/A' ? getValue(data.JaccardDistance).toFixed(4) : 'N/A'}</td>
                    `;
                    tbody.appendChild(row);
                }
            });
        });
    }

    function renderEfficiencyMetrics(data) {
        if (!data.EfficiencyMetrics) {
            showNoDataMessage();
            return;
        }

        const metrics = data.EfficiencyMetrics;
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        
        statsGrid.innerHTML = '';
        container.innerHTML = '';
        tbody.innerHTML = '';

        // Render stats from Summary
        if (metrics.Summary) {
            const summary = metrics.Summary;
            const stats = [
                {
                    icon: 'fa-microchip',
                    label: 'CPU Médio',
                    value: getValue(summary['Process_CPU_%']).toFixed(2) + '%',
                    color: 'var(--primary)'
                },
                {
                    icon: 'fa-memory',
                    label: 'Memória Média',
                    value: getValue(summary.Process_Memory_MB).toFixed(2) + ' MB',
                    color: 'var(--success)'
                },
                {
                    icon: 'fa-clock',
                    label: 'Tempo de Treinamento',
                    value: (getValue(summary.Time_training_ms) / 1000).toFixed(2) + ' s',
                    color: 'var(--warning)'
                },
                {
                    icon: 'fa-bolt',
                    label: 'Tempo de Geração',
                    value: getValue(summary.Time_generating_ms).toFixed(2) + ' ms',
                    color: 'var(--info)'
                }
            ];

            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <div class="stat-header">
                        <div class="stat-icon" style="background: ${stat.color}20; color: ${stat.color};">
                            <i class="fas ${stat.icon}"></i>
                        </div>
                    </div>
                    <div class="stat-value">${stat.value}</div>
                    <div class="stat-label">${stat.label}</div>
                `;
                statsGrid.appendChild(card);
            });
        }

        // Render charts
        const chartCard = document.createElement('div');
        chartCard.className = 'chart-card';
        chartCard.style.gridColumn = '1 / -1';
        chartCard.innerHTML = `
            <div class="chart-header">
                <h3 class="chart-title">Métricas de Eficiência por Fold</h3>
            </div>
            <div class="chart-container">
                <canvas id="efficiencyChart"></canvas>
            </div>
        `;
        container.appendChild(chartCard);

        // Create chart
        setTimeout(() => {
            const labels = [];
            const cpuData = [];
            const memoryData = [];
            const trainingTime = [];

            Object.entries(metrics).forEach(([fold, data]) => {
                if (fold !== 'Summary' && data) {
                    labels.push(fold);
                    cpuData.push(getValue(data['Process_CPU_%']).toFixed(2));
                    memoryData.push(getValue(data.Process_Memory_MB).toFixed(2));
                    trainingTime.push((getValue(data.Time_training_ms) / 1000).toFixed(2));
                }
            });

            const isDark = document.body.classList.contains('dark-mode');
            const textColor = isDark ? '#f1f5f9' : '#0f172a';
            const gridColor = isDark ? '#334155' : '#e5e7eb';

            charts.efficiency = new Chart(document.getElementById('efficiencyChart'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'CPU (%)',
                            data: cpuData,
                            borderColor: 'rgba(59, 130, 246, 1)',
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderWidth: 2,
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Memória (MB)',
                            data: memoryData,
                            borderColor: 'rgba(16, 185, 129, 1)',
                            backgroundColor: 'rgba(16, 185, 129, 0.2)',
                            borderWidth: 2,
                            tension: 0.4,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Tempo Treinamento (s)',
                            data: trainingTime,
                            borderColor: 'rgba(245, 158, 11, 1)',
                            backgroundColor: 'rgba(245, 158, 11, 0.2)',
                            borderWidth: 2,
                            tension: 0.4,
                            yAxisID: 'y2'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: textColor } }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: { display: true, text: 'CPU (%)', color: textColor },
                            grid: { color: gridColor },
                            ticks: { color: textColor }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Memória (MB)', color: textColor },
                            grid: { display: false },
                            ticks: { color: textColor }
                        },
                        y2: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Tempo (s)', color: textColor },
                            grid: { display: false },
                            ticks: { color: textColor }
                        },
                        x: {
                            grid: { display: false },
                            ticks: { color: textColor }
                        }
                    }
                }
            });
        }, 100);

        // Render table
        const thead = document.querySelector('#metricsTable thead tr');
        thead.innerHTML = `
            <th>Fold</th>
            <th>Process CPU %</th>
            <th>Process Memory MB</th>
            <th>System CPU %</th>
            <th>System Memory MB</th>
            <th>Training Time (s)</th>
            <th>Generating Time (ms)</th>
        `;

        Object.entries(metrics).forEach(([fold, data]) => {
            if (data && typeof data === 'object') {
                const row = document.createElement('tr');
                if (fold === 'Summary') {
                    row.style.fontWeight = 'bold';
                    row.style.background = isDarkMode ? '#0f172a' : '#f9fafb';
                }
                
                row.innerHTML = `
                    <td>${fold === 'Summary' ? 'Média (Summary)' : fold}</td>
                    <td>${getValue(data['Process_CPU_%']).toFixed(2)}</td>
                    <td>${getValue(data.Process_Memory_MB).toFixed(2)}</td>
                    <td>${getValue(data['System_CPU_%']).toFixed(2)}</td>
                    <td>${getValue(data.System_Memory_MB).toFixed(2)}</td>
                    <td>${(getValue(data.Time_training_ms) / 1000).toFixed(2)}</td>
                    <td>${getValue(data.Time_generating_ms).toFixed(2)}</td>
                `;
                tbody.appendChild(row);
            }
        });
    }

    function renderSDVMetrics(data) {
        if (!data.SDVMetrics) {
            showNoDataMessage();
            return;
        }

        const metrics = data.SDVMetrics;
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        
        statsGrid.innerHTML = '';
        container.innerHTML = '';
        tbody.innerHTML = '';

        // Render stats
        if (metrics.Summary) {
            const stats = [
                {
                    icon: 'fa-check-circle',
                    label: 'Diagnostic Score',
                    value: getValue(metrics.Summary.diagnostic).toFixed(4),
                    color: 'var(--success)'
                },
                {
                    icon: 'fa-star',
                    label: 'Quality Score',
                    value: getValue(metrics.Summary.quality).toFixed(4),
                    color: 'var(--warning)'
                }
            ];

            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <div class="stat-header">
                        <div class="stat-icon" style="background: ${stat.color}20; color: ${stat.color};">
                            <i class="fas ${stat.icon}"></i>
                        </div>
                    </div>
                    <div class="stat-value">${stat.value}</div>
                    <div class="stat-label">${stat.label}</div>
                `;
                statsGrid.appendChild(card);
            });
        }

        // Render chart
        const chartCard = document.createElement('div');
        chartCard.className = 'chart-card';
        chartCard.innerHTML = `
            <div class="chart-header">
                <h3 class="chart-title">SDV Metrics por Fold</h3>
            </div>
            <div class="chart-container">
                <canvas id="sdvChart"></canvas>
            </div>
        `;
        container.appendChild(chartCard);

        setTimeout(() => {
            const labels = [];
            const diagnostic = [];
            const quality = [];

            Object.entries(metrics).forEach(([fold, data]) => {
                if (fold !== 'Summary' && data) {
                    labels.push(fold);
                    diagnostic.push(getValue(data.diagnostic));
                    quality.push(getValue(data.quality));
                }
            });

            const isDark = document.body.classList.contains('dark-mode');
            const textColor = isDark ? '#f1f5f9' : '#0f172a';
            const gridColor = isDark ? '#334155' : '#e5e7eb';

            charts.sdv = new Chart(document.getElementById('sdvChart'), {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Diagnostic',
                            data: diagnostic,
                            backgroundColor: 'rgba(16, 185, 129, 0.8)',
                            borderColor: 'rgba(16, 185, 129, 1)',
                            borderWidth: 2,
                            borderRadius: 8
                        },
                        {
                            label: 'Quality',
                            data: quality,
                            backgroundColor: 'rgba(245, 158, 11, 0.8)',
                            borderColor: 'rgba(245, 158, 11, 1)',
                            borderWidth: 2,
                            borderRadius: 8
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: textColor } }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { color: gridColor },
                            ticks: { color: textColor }
                        },
                        x: {
                            grid: { display: false },
                            ticks: { color: textColor }
                        }
                    }
                }
            });
        }, 100);

        // Render table
        const thead = document.querySelector('#metricsTable thead tr');
        thead.innerHTML = `
            <th>Fold</th>
            <th>Diagnostic Score</th>
            <th>Quality Score</th>
        `;

        Object.entries(metrics).forEach(([fold, data]) => {
            if (data && typeof data === 'object') {
                const row = document.createElement('tr');
                if (fold === 'Summary') {
                    row.style.fontWeight = 'bold';
                    row.style.background = isDarkMode ? '#0f172a' : '#f9fafb';
                }
                
                row.innerHTML = `
                    <td>${fold === 'Summary' ? 'Média (Summary)' : fold}</td>
                    <td>${getValue(data.diagnostic).toFixed(4)}</td>
                    <td>${getValue(data.quality).toFixed(4)}</td>
                `;
                tbody.appendChild(row);
            }
        });
    }

    function renderArguments(data) {
        if (!data.Arguments) {
            showNoDataMessage();
            return;
        }

        const args = data.Arguments;
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        
        statsGrid.innerHTML = '';
        container.innerHTML = '';
        tbody.innerHTML = '';

        // Show key arguments as stats
        const keyArgs = [
            { key: 'model_type', label: 'Tipo de Modelo', icon: 'fa-brain' },
            { key: 'number_k_folds', label: 'Número de Folds', icon: 'fa-layer-group' },
            { key: 'adversarial_number_epochs', label: 'Epochs', icon: 'fa-sync' },
            { key: 'adversarial_batch_size', label: 'Batch Size', icon: 'fa-cubes' }
        ];

        const colors = ['var(--primary)', 'var(--success)', 'var(--warning)', 'var(--info)'];

        keyArgs.forEach((arg, i) => {
            const value = args[arg.key];
            if (value !== undefined) {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <div class="stat-header">
                        <div class="stat-icon" style="background: ${colors[i]}20; color: ${colors[i]};">
                            <i class="fas ${arg.icon}"></i>
                        </div>
                    </div>
                    <div class="stat-value">${typeof value === 'object' ? JSON.stringify(value) : value}</div>
                    <div class="stat-label">${arg.label}</div>
                `;
                statsGrid.appendChild(card);
            }
        });

        // Show all arguments in a formatted view
        const argsCard = document.createElement('div');
        argsCard.className = 'chart-card';
        argsCard.style.gridColumn = '1 / -1';
        argsCard.innerHTML = `
            <div class="chart-header">
                <h3 class="chart-title">Todos os Argumentos</h3>
            </div>
            <div style="padding: 1rem; max-height: 400px; overflow-y: auto;">
                <pre style="background: ${isDarkMode ? '#0f172a' : '#f9fafb'}; padding: 1rem; border-radius: 0.5rem; font-size: 0.875rem;">${JSON.stringify(args, null, 2)}</pre>
            </div>
        `;
        container.appendChild(argsCard);

        // Render table
        const thead = document.querySelector('#metricsTable thead tr');
        thead.innerHTML = `
            <th>Parâmetro</th>
            <th>Valor</th>
        `;

        Object.entries(args).forEach(([key, value]) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><code>${key}</code></td>
                <td>${typeof value === 'object' ? JSON.stringify(value) : value}</td>
            `;
            tbody.appendChild(row);
        });
    }

    // Settings and Monitoring Functions
    function renderSettings() {
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        
        statsGrid.innerHTML = '';
        tbody.innerHTML = '';
        
        const isDark = document.body.classList.contains('dark-mode');
        
        container.innerHTML = `
            <div class="settings-container" style="grid-column: 1/-1;">
                <!-- Chart Colors Panel -->
                <div class="settings-panel">
                    <div class="settings-panel-header">
                        <div class="settings-panel-icon" style="background: rgba(59, 130, 246, 0.1); color: var(--primary);">
                            <i class="fas fa-palette"></i>
                        </div>
                        <h3 class="settings-panel-title">Cores dos Gráficos</h3>
                    </div>
                    <div class="settings-group">
                        <div class="color-picker-group">
                            <input type="color" id="colorPrimary" class="color-picker" value="${chartSettings.colors.primary}" onchange="updateChartColor('primary', this.value)">
                            <label class="color-label">Cor Primária</label>
                        </div>
                        <div class="color-picker-group">
                            <input type="color" id="colorSecondary" class="color-picker" value="${chartSettings.colors.secondary}" onchange="updateChartColor('secondary', this.value)">
                            <label class="color-label">Cor Secundária</label>
                        </div>
                        <div class="color-picker-group">
                            <input type="color" id="colorSuccess" class="color-picker" value="${chartSettings.colors.success}" onchange="updateChartColor('success', this.value)">
                            <label class="color-label">Cor de Sucesso</label>
                        </div>
                        <div class="color-picker-group">
                            <input type="color" id="colorWarning" class="color-picker" value="${chartSettings.colors.warning}" onchange="updateChartColor('warning', this.value)">
                            <label class="color-label">Cor de Aviso</label>
                        </div>
                        <button class="btn btn-secondary" style="width: 100%; margin-top: 1rem;" onclick="resetColors()">
                            <i class="fas fa-undo"></i> Restaurar Cores Padrão
                        </button>
                    </div>
                </div>

                <!-- Chart Types Panel -->
                <div class="settings-panel">
                    <div class="settings-panel-header">
                        <div class="settings-panel-icon" style="background: rgba(139, 92, 246, 0.1); color: var(--secondary);">
                            <i class="fas fa-chart-bar"></i>
                        </div>
                        <h3 class="settings-panel-title">Tipos de Gráficos</h3>
                    </div>
                    <div class="settings-group">
                        <label class="settings-label">Gráfico de Accuracy</label>
                        <select class="settings-select" onchange="updateChartType('accuracy', this.value)">
                            <option value="bar">Barras</option>
                            <option value="line">Linhas</option>
                            <option value="radar">Radar</option>
                        </select>

                        <label class="settings-label" style="margin-top: 1rem;">Gráfico de F1-Score</label>
                        <select class="settings-select" onchange="updateChartType('f1', this.value)">
                            <option value="bar">Barras</option>
                            <option value="line">Linhas</option>
                            <option value="radar">Radar</option>
                        </select>
                    </div>
                </div>

                <!-- Display Options Panel -->
                <div class="settings-panel">
                    <div class="settings-panel-header">
                        <div class="settings-panel-icon" style="background: rgba(16, 185, 129, 0.1); color: var(--success);">
                            <i class="fas fa-eye"></i>
                        </div>
                        <h3 class="settings-panel-title">Opções de Visualização</h3>
                    </div>
                    <div class="settings-group">
                        <div class="switch-container">
                            <label class="settings-label" style="margin: 0;">Mostrar Legendas</label>
                            <label class="switch">
                                <input type="checkbox" ${chartSettings.showLegend ? 'checked' : ''} onchange="toggleSetting('showLegend', this.checked)">
                                <span class="slider"></span>
                            </label>
                        </div>

                        <div class="switch-container">
                            <label class="settings-label" style="margin: 0;">Animações</label>
                            <label class="switch">
                                <input type="checkbox" ${chartSettings.animationEnabled ? 'checked' : ''} onchange="toggleSetting('animationEnabled', this.checked)">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Export Options Panel -->
                <div class="settings-panel">
                    <div class="settings-panel-header">
                        <div class="settings-panel-icon" style="background: rgba(245, 158, 11, 0.1); color: var(--warning);">
                            <i class="fas fa-download"></i>
                        </div>
                        <h3 class="settings-panel-title">Exportação</h3>
                    </div>
                    <div class="settings-group">
                        <button class="btn btn-primary" style="width: 100%; margin-bottom: 0.5rem;" onclick="exportChartsAsPDF()">
                            <i class="fas fa-file-pdf"></i> Exportar como PDF
                        </button>
                        <button class="btn btn-secondary" style="width: 100%;" onclick="exportChartsAsImages()">
                            <i class="fas fa-image"></i> Exportar como Imagens
                        </button>
                    </div>
                </div>
            </div>
        `;
    }

    function renderSystemMonitoring() {
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        
        tbody.innerHTML = '';
        
        const now = new Date();
        const systemInfo = getSystemInfo();
        
        statsGrid.innerHTML = `
            <div class="stat-card">
                <div class="stat-header">
                    <div class="stat-icon" style="background: rgba(59, 130, 246, 0.1); color: var(--primary);">
                        <i class="fas fa-database"></i>
                    </div>
                </div>
                <div class="stat-value">${Object.keys(allExperiments).length}</div>
                <div class="stat-label">Experimentos</div>
            </div>

            <div class="stat-card">
                <div class="stat-header">
                    <div class="stat-icon" style="background: rgba(16, 185, 129, 0.1); color: var(--success);">
                        <i class="fas fa-clock"></i>
                    </div>
                </div>
                <div class="stat-value">${now.toLocaleTimeString('pt-BR')}</div>
                <div class="stat-label">Hora Atual</div>
            </div>

            <div class="stat-card">
                <div class="stat-header">
                    <div class="stat-icon" style="background: rgba(245, 158, 11, 0.1); color: var(--warning);">
                        <i class="fas fa-chart-line"></i>
                    </div>
                </div>
                <div class="stat-value">${Object.keys(charts).length}</div>
                <div class="stat-label">Gráficos Ativos</div>
            </div>

            <div class="stat-card">
                <div class="stat-header">
                    <div class="stat-icon" style="background: rgba(6, 182, 212, 0.1); color: var(--info);">
                        <i class="fas fa-memory"></i>
                    </div>
                </div>
                <div class="stat-value">${systemInfo.memory}</div>
                <div class="stat-label">Memória</div>
            </div>
        `;

        container.innerHTML = `
            <div class="monitoring-grid" style="grid-column: 1/-1;">
                <div class="monitor-card">
                    <div class="monitor-header">
                        <div class="monitor-icon" style="background: rgba(59, 130, 246, 0.1); color: var(--primary);">
                            <i class="fas fa-microchip"></i>
                        </div>
                        <div class="monitor-info">
                            <h3>Performance</h3>
                            <div class="monitor-value">${systemInfo.performance}%</div>
                        </div>
                    </div>
                    <div class="monitor-progress">
                        <div class="monitor-progress-bar" style="width: ${systemInfo.performance}%; background: var(--primary);"></div>
                    </div>
                </div>

                <div class="monitor-card">
                    <div class="monitor-header">
                        <div class="monitor-icon" style="background: rgba(16, 185, 129, 0.1); color: var(--success);">
                            <i class="fas fa-server"></i>
                        </div>
                        <div class="monitor-info">
                            <h3>Sessão</h3>
                            <div class="monitor-value" style="font-size: 1.25rem;">${systemInfo.sessionDuration}</div>
                        </div>
                    </div>
                </div>

                <div class="monitor-card">
                    <div class="monitor-header">
                        <div class="monitor-icon" style="background: rgba(245, 158, 11, 0.1); color: var(--warning);">
                            <i class="fas fa-hdd"></i>
                        </div>
                        <div class="monitor-info">
                            <h3>Armazenamento</h3>
                            <div class="monitor-value">${systemInfo.storageUsed}</div>
                        </div>
                    </div>
                    <div class="monitor-progress">
                        <div class="monitor-progress-bar" style="width: ${systemInfo.storagePercent}%; background: var(--warning);"></div>
                    </div>
                </div>

                <div class="monitor-card">
                    <div class="monitor-header">
                        <div class="monitor-icon" style="background: rgba(6, 182, 212, 0.1); color: var(--info);">
                            <i class="fas fa-globe"></i>
                        </div>
                        <div class="monitor-info">
                            <h3>Conexão</h3>
                            <div class="monitor-value" style="font-size: 1.25rem;">${systemInfo.connectionStatus}</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="chart-card" style="grid-column: 1/-1; margin-top: 1rem;">
                <div class="chart-header">
                    <h3 class="chart-title">
                        <i class="fas fa-info-circle"></i>
                        Informações do Sistema
                    </h3>
                    <button class="icon-btn" onclick="renderSystemMonitoring()">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                </div>
                <div style="padding: 1.5rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
                    <div><strong>SO:</strong> ${systemInfo.os}</div>
                    <div><strong>Navegador:</strong> ${systemInfo.browser}</div>
                    <div><strong>Resolução:</strong> ${systemInfo.screenResolution}</div>
                    <div><strong>Idioma:</strong> ${systemInfo.language}</div>
                    <div><strong>Registros:</strong> ${systemInfo.totalRecords}</div>
                    <div><strong>Modo:</strong> ${document.body.classList.contains('dark-mode') ? 'Escuro' : 'Claro'}</div>
                </div>
            </div>
        `;
    }

    function getSystemInfo() {
        const now = new Date();
        const sessionStart = new Date(now.getTime() - Math.random() * 3600000);
        const duration = Math.floor((now - sessionStart) / 1000);
        const hours = Math.floor(duration / 3600);
        const minutes = Math.floor((duration % 3600) / 60);
        const seconds = duration % 60;
        
        let dataSize = 0;
        Object.values(allExperiments).forEach(exp => {
            dataSize += JSON.stringify(exp).length;
        });
        const dataSizeMB = (dataSize / 1024 / 1024).toFixed(2);
        
        let recordCount = 0;
        Object.values(allExperiments).forEach(exp => {
            const sections = ['TS-TR', 'TR-TS', 'TR-TR'];
            sections.forEach(section => {
                if (exp[section]) {
                    Object.values(exp[section]).forEach(model => {
                        Object.keys(model).forEach(fold => {
                            if (fold.includes('Fold')) recordCount++;
                        });
                    });
                }
            });
        });

        return {
            memory: dataSizeMB + ' MB',
            performance: Math.floor(85 + Math.random() * 10),
            responseTime: Math.floor(10 + Math.random() * 20),
            sessionDuration: `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`,
            sessionStart: sessionStart.toLocaleTimeString('pt-BR'),
            storageUsed: dataSizeMB + ' MB',
            storageAvailable: '100 MB',
            storagePercent: Math.min(parseFloat(dataSizeMB) / 100 * 100, 100).toFixed(0),
            connectionStatus: navigator.onLine ? 'Online' : 'Offline',
            connectionType: (navigator.connection && navigator.connection.effectiveType) || 'Desconhecido',
            screenResolution: `${window.screen.width} x ${window.screen.height}`,
            browser: navigator.userAgent.match(/(Firefox|Chrome|Safari|Edge|Opera)\/[\d.]+/)?.[0] || 'Desconhecido',
            os: navigator.platform,
            platform: navigator.platform,
            userAgent: navigator.userAgent,
            language: navigator.language,
            dataProcessed: dataSizeMB + ' MB',
            totalRecords: recordCount.toLocaleString('pt-BR')
        };
    }

    // Chart customization functions
    function updateChartColor(colorName, colorValue) {
        chartSettings.colors[colorName] = colorValue;
        document.documentElement.style.setProperty(`--${colorName}`, colorValue);
        if (currentExperiment && currentTab === 'classification') {
            renderDashboard();
        }
        showNotification(`Cor ${colorName} atualizada`, 'success');
    }

    function resetColors() {
        chartSettings.colors = {
            primary: '#3b82f6',
            secondary: '#8b5cf6',
            success: '#10b981',
            warning: '#f59e0b',
            danger: '#ef4444',
            info: '#06b6d4'
        };
        
        Object.entries(chartSettings.colors).forEach(([name, value]) => {
            document.documentElement.style.setProperty(`--${name}`, value);
            const input = document.getElementById(`color${name.charAt(0).toUpperCase() + name.slice(1)}`);
            if (input) input.value = value;
        });
        
        if (currentExperiment) {
            renderDashboard();
        }
        showNotification('Cores restauradas para o padrão', 'success');
    }

    function updateChartType(chartName, chartType) {
        chartSettings.chartType[chartName] = chartType;
        if (currentExperiment && currentTab === 'classification') {
            renderDashboard();
        }
        showNotification(`Tipo de gráfico atualizado para ${chartType}`, 'success');
    }

    function toggleSetting(setting, value) {
        chartSettings[setting] = value;
        if (currentExperiment) {
            renderDashboard();
        }
        showNotification(`${setting} ${value ? 'ativado' : 'desativado'}`, 'success');
    }

    function updateAnimationDuration(value) {
        chartSettings.animationDuration = parseInt(value);
        showNotification(`Duração da animação: ${value}ms`, 'info');
    }

    function toggleMonitoring(enabled) {
        systemMonitoring.enabled = enabled;
        if (enabled) {
            showNotification('Monitoramento ativado', 'success');
            if (currentTab === 'monitoring') {
                renderSystemMonitoring();
            }
        } else {
            showNotification('Monitoramento desativado', 'info');
        }
    }

    function updateMonitoringInterval(value) {
        systemMonitoring.refreshInterval = parseInt(value);
        showNotification(`Intervalo de atualização: ${value}ms`, 'info');
    }

    function exportChartsAsPDF() {
        showNotification('Exportando gráficos como PDF...', 'info');
        
        // Simulate PDF export with a delay
        setTimeout(() => {
            showNotification('Gráficos exportados com sucesso!', 'success');
            // In a real implementation, you would use a library like jsPDF or html2canvas
            console.log('PDF export would happen here');
        }, 1500);
    }

    function exportChartsAsImages() {
        showNotification('Exportando gráficos como imagens...', 'info');
        
        setTimeout(() => {
            const chartElements = document.querySelectorAll('canvas');
            chartElements.forEach((canvas, index) => {
                const link = document.createElement('a');
                link.download = `chart_${index + 1}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
            showNotification(`${chartElements.length} imagens exportadas`, 'success');
        }, 500);
    }

    function exportAllData() {
        const allData = {
            experiments: allExperiments,
            metadata: experimentMetadata,
            settings: chartSettings,
            exportDate: new Date().toISOString()
        };
        
        const json = JSON.stringify(allData, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `all_data_${new Date().getTime()}.json`;
        a.click();
        window.URL.revokeObjectURL(url);
        
        showNotification('Todos os dados exportados', 'success');
    }

    function showAboutDialog() {
        alert('SynDataGen Analytics Platform v2.0.0\n\nPlataforma avançada para análise de dados sintéticos com visualizações interativas.\n\nDesenvolvido com Chart.js, HTML5, CSS3 e JavaScript.');
    }
    function showNoDataMessage() {
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        
        statsGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; padding: 2rem; color: #9ca3af;">Nenhum dado disponível para esta seção</div>';
        container.innerHTML = '';
        tbody.innerHTML = '';
    }

    // UI Functions
    function toggleSidebar() {
        const sidebar = document.getElementById('sidebar');
        const mainContent = document.getElementById('mainContent');
        const menuToggle = document.getElementById('menuToggle');

        isSidebarOpen = !isSidebarOpen;

        if (isSidebarOpen) {
            sidebar.classList.remove('collapsed');
            mainContent.classList.remove('expanded');
            menuToggle.innerHTML = '<i class="fas fa-bars"></i>';
        } else {
            sidebar.classList.add('collapsed');
            mainContent.classList.add('expanded');
            menuToggle.innerHTML = '<i class="fas fa-times"></i>';
        }
    }

    function toggleTheme() {
        isDarkMode = !isDarkMode;
        document.body.classList.toggle('dark-mode');
        document.getElementById('themeIcon').className = isDarkMode ? 'fas fa-sun' : 'fas fa-moon';

        if (currentExperiment) {
            renderDashboard();
        }
    }

    function exportCurrentExperiment() {
        if (!currentExperiment) {
            showNotification('Nenhum experimento selecionado', 'error');
            return;
        }

        const data = allExperiments[currentExperiment];
        let csv = '';
        
        if (currentTab === 'classification' && data.ClassificationMetrics) {
            csv = 'Modelo,Fold,Accuracy,F1-Score,Precision,Recall,MSE,MAE\n';
            Object.entries(data.ClassificationMetrics).forEach(([model, folds]) => {
                Object.entries(folds).forEach(([fold, metrics]) => {
                    if (metrics && typeof metrics === 'object') {
                        const acc = getValue(metrics.Accuracy) * 100;
                        const f1 = getValue(metrics.F1Score) * 100;
                        const prec = getValue(metrics.Precision) * 100;
                        const rec = getValue(metrics.Recall) * 100;
                        const mse = getValue(metrics.MeanSquareError);
                        const mae = getValue(metrics.MeanAbsoluteError);
                        
                        csv += `${model},${fold},${acc.toFixed(2)},${f1.toFixed(2)},${prec.toFixed(2)},${rec.toFixed(2)},${mse.toFixed(4)},${mae.toFixed(4)}\n`;
                    }
                });
            });
        } else {
            csv = JSON.stringify(data, null, 2);
        }

        const blob = new Blob([csv], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const displayName = experimentMetadata[currentExperiment]?.originalName || currentExperiment;
        a.download = `${displayName}_${currentTab}_report.csv`;
        a.click();
        window.URL.revokeObjectURL(url);
        
        showNotification('Arquivo CSV exportado com sucesso', 'success');
    }

    async function exportAsPDF() {
        if (!currentExperiment && currentTab !== 'monitoring' && currentTab !== 'settings') {
            showNotification('Selecione um experimento para exportar', 'warning');
            return;
        }

        showNotification('Gerando PDF...', 'info');

        try {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            
            const displayName = currentExperiment ? 
                (experimentMetadata[currentExperiment]?.originalName || currentExperiment) : 
                'Sistema';
            
            // Add title
            pdf.setFontSize(20);
            pdf.setTextColor(59, 130, 246);
            pdf.text(`Relatório - ${displayName}`, 15, 20);
            
            pdf.setFontSize(12);
            pdf.setTextColor(100);
            pdf.text(`Aba: ${currentTab.charAt(0).toUpperCase() + currentTab.slice(1)}`, 15, 30);
            pdf.text(`Data: ${new Date().toLocaleString('pt-BR')}`, 15, 37);
            
            // Capture stats section
            const statsGrid = document.getElementById('statsGrid');
            if (statsGrid && statsGrid.children.length > 0) {
                const statsCanvas = await html2canvas(statsGrid, {
                    scale: 2,
                    backgroundColor: isDarkMode ? '#0f172a' : '#ffffff'
                });
                const statsImg = statsCanvas.toDataURL('image/png');
                pdf.addImage(statsImg, 'PNG', 15, 45, 180, (statsCanvas.height * 180) / statsCanvas.width);
            }
            
            // Capture charts section
            const chartsContainer = document.getElementById('chartsContainer');
            if (chartsContainer && chartsContainer.children.length > 0) {
                pdf.addPage();
                pdf.setFontSize(16);
                pdf.setTextColor(59, 130, 246);
                pdf.text('Gráficos e Visualizações', 15, 20);
                
                const chartsCanvas = await html2canvas(chartsContainer, {
                    scale: 2,
                    backgroundColor: isDarkMode ? '#0f172a' : '#ffffff'
                });
                const chartsImg = chartsCanvas.toDataURL('image/png');
                pdf.addImage(chartsImg, 'PNG', 15, 30, 180, (chartsCanvas.height * 180) / chartsCanvas.width);
            }
            
            // Capture table if exists
            const table = document.getElementById('metricsTable');
            if (table) {
                pdf.addPage();
                pdf.setFontSize(16);
                pdf.setTextColor(59, 130, 246);
                pdf.text('Tabela de Métricas Detalhadas', 15, 20);
                
                const tableCanvas = await html2canvas(table, {
                    scale: 2,
                    backgroundColor: isDarkMode ? '#0f172a' : '#ffffff'
                });
                const tableImg = tableCanvas.toDataURL('image/png');
                pdf.addImage(tableImg, 'PNG', 15, 30, 180, (tableCanvas.height * 180) / tableCanvas.width);
            }
            
            // Save PDF
            pdf.save(`${displayName}_${currentTab}_${Date.now()}.pdf`);
            showNotification('PDF exportado com sucesso!', 'success');
            
        } catch (error) {
            console.error('Erro ao exportar PDF:', error);
            showNotification('Erro ao exportar PDF', 'error');
        }
    }

    function shareExperiment() {
        const url = window.location.href;
        navigator.clipboard.writeText(url).then(() => {
            showNotification('Link copiado para área de transferência!', 'success');
        }).catch(() => {
            showNotification('Erro ao copiar link', 'error');
        });
    }

    function refreshExperiment() {
        if (currentExperiment) {
            renderDashboard();
        }
    }

    function refreshCharts() {
        if (currentExperiment) {
            renderDashboard();
            showNotification('Gráficos atualizados', 'success');
        }
    }

    function downloadCharts() {
        showNotification('Download de gráficos em desenvolvimento', 'info');
    }

    function generateReport() {
        showNotification('Funcionalidade de relatório em desenvolvimento', 'info');
    }

    function filterTable(searchTerm) {
        const table = document.getElementById('metricsTable');
        const rows = table.getElementsByTagName('tr');

        for (let i = 1; i < rows.length; i++) {
            const firstCell = rows[i].cells[0]?.textContent || '';
            if (firstCell.toLowerCase().includes(searchTerm.toLowerCase())) {
                rows[i].style.display = '';
            } else {
                rows[i].style.display = 'none';
            }
        }
    }

    function filterByMetric(criteria) {
        if (currentTab !== 'classification') return;
        
        const table = document.getElementById('metricsTable');
        const rows = table.getElementsByTagName('tr');

        for (let i = 1; i < rows.length; i++) {
            const accCell = rows[i].cells[2];
            if (!accCell) continue;
            
            const accText = accCell.textContent;
            const acc = parseFloat(accText.replace('%', ''));

            let show = true;
            if (criteria === 'high' && acc < 70) show = false;
            if (criteria === 'medium' && (acc < 50 || acc >= 70)) show = false;
            if (criteria === 'low' && acc >= 50) show = false;

            rows[i].style.display = show ? '' : 'none';
        }
    }

    function sortTable(columnIndex) {
        const table = document.getElementById('metricsTable');
        const tbody = table.getElementsByTagName('tbody')[0];
        const rows = Array.from(tbody.getElementsByTagName('tr'));

        rows.sort((a, b) => {
            const aVal = a.cells[columnIndex]?.textContent || '';
            const bVal = b.cells[columnIndex]?.textContent || '';

            const aNum = parseFloat(aVal.replace(/[^0-9.-]/g, ''));
            const bNum = parseFloat(bVal.replace(/[^0-9.-]/g, ''));

            if (!isNaN(aNum) && !isNaN(bNum)) {
                return bNum - aNum;
            }
            return aVal.localeCompare(bVal);
        });

        rows.forEach(row => tbody.appendChild(row));
    }

    function toggleComparisonMode() {
        comparisonMode = !comparisonMode;
        alert(comparisonMode ? 'Modo comparação ativado!' : 'Modo comparação desativado!');
    }

    function compareExperiments() {
        const experimentNames = Object.keys(allExperiments);
        if (experimentNames.length < 2) {
            showNotification('É necessário ter pelo menos 2 experimentos para comparar', 'error');
            return;
        }
        
        // Create comparison data
        let comparisonData = 'Experimento,';
        
        // Get metric names from first experiment
        const firstExp = allExperiments[experimentNames[0]];
        const evaluationSections = ['TS-TR', 'TR-TS', 'TR-TR'];
        
        // Try to get classification data from evaluation sections or ClassificationMetrics
        let classificationData = null;
        for (const section of evaluationSections) {
            if (firstExp[section]) {
                classificationData = firstExp[section];
                break;
            }
        }
        
        if (!classificationData && firstExp.ClassificationMetrics) {
            classificationData = firstExp.ClassificationMetrics;
        }
        
        if (classificationData) {
            const firstModel = Object.keys(classificationData)[0];
            const summary = classificationData[firstModel].Summary;
            if (summary) {
                const metrics = Object.keys(summary).filter(k => k !== 'Summary');
                comparisonData += metrics.join(',') + '\n';
                
                // Add data for each experiment
                experimentNames.forEach(expName => {
                    const exp = allExperiments[expName];
                    const displayName = experimentMetadata[expName]?.originalName || expName;
                    comparisonData += `${displayName},`;
                    
                    // Get classification data for this experiment
                    let expClassData = null;
                    for (const section of evaluationSections) {
                        if (exp[section]) {
                            expClassData = exp[section];
                            break;
                        }
                    }
                    
                    if (!expClassData && exp.ClassificationMetrics) {
                        expClassData = exp.ClassificationMetrics;
                    }
                    
                    if (expClassData) {
                        // Average across all models
                        let avgMetrics = {};
                        let modelCount = 0;
                        
                        Object.values(expClassData).forEach(model => {
                            if (model.Summary) {
                                modelCount++;
                                metrics.forEach(metric => {
                                    if (!avgMetrics[metric]) avgMetrics[metric] = 0;
                                    avgMetrics[metric] += getValue(model.Summary[metric]);
                                });
                            }
                        });
                        
                        // Calculate averages
                        metrics.forEach(metric => {
                            const avg = modelCount > 0 ? (avgMetrics[metric] / modelCount).toFixed(4) : '0';
                            comparisonData += avg + ',';
                        });
                        comparisonData = comparisonData.slice(0, -1) + '\n';
                    }
                });
            }
        }
        
        // Download comparison CSV
        const blob = new Blob([comparisonData], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'experiments_comparison.csv';
        a.click();
        window.URL.revokeObjectURL(url);
        
        showNotification('Comparação exportada com sucesso', 'success');
    }

    function exportAllExperiments() {
        if (Object.keys(allExperiments).length === 0) {
            showNotification('Nenhum experimento para exportar', 'error');
            return;
        }
        
        // Create a combined JSON with all experiments
        const combinedData = {
            exportDate: new Date().toISOString(),
            experimentsCount: Object.keys(allExperiments).length,
            experiments: {}
        };
        
        Object.entries(allExperiments).forEach(([name, data]) => {
            const displayName = experimentMetadata[name]?.originalName || name;
            combinedData.experiments[displayName] = {
                metadata: experimentMetadata[name],
                data: data
            };
        });
        
        const json = JSON.stringify(combinedData, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `all_experiments_${new Date().getTime()}.json`;
        a.click();
        window.URL.revokeObjectURL(url);
        
        showNotification(`${Object.keys(allExperiments).length} experimentos exportados`, 'success');
    }

    function downloadAllReports() {
        alert('Baixando todos os relatórios...');
    }

    function showNotificationsCenter() {
        showNotification('Central de notificações em desenvolvimento', 'info');
    }

    function showSettings() {
        showNotification('Configurações em desenvolvimento', 'info');
    }

    function resetDashboard() {
        if (confirm('Deseja limpar todos os dados e voltar ao início?')) {
            const count = Object.keys(allExperiments).length;
            
            allExperiments = {};
            experimentMetadata = {};
            currentExperiment = null;
            currentTab = 'classification';

            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('dashboardContent').style.display = 'none';
            document.getElementById('experimentList').innerHTML = '';
            document.getElementById('totalExperiments').textContent = '0';

            Object.values(charts).forEach(chart => chart?.destroy());
            charts = {};
            
            showNotification(`${count} experimento(s) removido(s)`, 'success');
        }
    }

    // ========== SYSTEM MONITORING ==========
    function renderSystemMonitoring() {
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        const thead = document.querySelector('#metricsTable thead tr');
        
        statsGrid.innerHTML = '';
        container.innerHTML = '';
        tbody.innerHTML = '';
        thead.innerHTML = '';

        // Add realtime indicator
        const indicatorHtml = `
            <div style="display: flex; justify-content: center; margin-bottom: 2rem;">
                <div class="realtime-indicator">
                    <div class="pulse-dot"></div>
                    Monitoramento em Tempo Real
                </div>
            </div>
        `;
        
        const indicatorDiv = document.createElement('div');
        indicatorDiv.innerHTML = indicatorHtml;
        statsGrid.appendChild(indicatorDiv);

        // Create monitoring cards
        const monitoringCards = [
            {
                id: 'cpu',
                icon: 'fa-microchip',
                label: 'Uso de CPU',
                color: '#3b82f6',
                unit: '%',
                getValue: () => systemStats.cpu
            },
            {
                id: 'memory',
                icon: 'fa-memory',
                label: 'Uso de Memória',
                color: '#10b981',
                unit: '%',
                getValue: () => systemStats.memory
            },
            {
                id: 'performance',
                icon: 'fa-bolt',
                label: 'Performance',
                color: '#f59e0b',
                unit: '%',
                getValue: () => systemStats.performance
            },
            {
                id: 'fps',
                icon: 'fa-video',
                label: 'FPS',
                color: '#8b5cf6',
                unit: '',
                getValue: () => systemStats.fps
            },
            {
                id: 'latency',
                icon: 'fa-network-wired',
                label: 'Latência',
                color: '#06b6d4',
                unit: 'ms',
                getValue: () => systemStats.latency
            },
            {
                id: 'experiments',
                icon: 'fa-database',
                label: 'Experimentos Carregados',
                color: '#ec4899',
                unit: '',
                getValue: () => Object.keys(allExperiments).length
            }
        ];

        monitoringCards.forEach(card => {
            const cardEl = document.createElement('div');
            cardEl.className = 'monitor-card';
            cardEl.innerHTML = `
                <div class="monitor-icon" style="background: ${card.color}20; color: ${card.color};">
                    <i class="fas ${card.icon}"></i>
                </div>
                <div class="monitor-label">${card.label}</div>
                <div class="monitor-value" id="${card.id}-value">
                    ${card.getValue()}${card.unit}
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="${card.id}-progress" style="width: ${card.getValue()}%"></div>
                </div>
                <div class="monitor-status status-healthy" id="${card.id}-status">Normal</div>
            `;
            statsGrid.appendChild(cardEl);
        });

        // Create system info chart
        const chartCard = document.createElement('div');
        chartCard.className = 'chart-card';
        chartCard.style.gridColumn = '1 / -1';
        chartCard.innerHTML = `
            <div class="chart-header">
                <h3 class="chart-title">Métricas do Sistema em Tempo Real</h3>
            </div>
            <div class="chart-container">
                <canvas id="systemChart"></canvas>
            </div>
        `;
        container.appendChild(chartCard);

        // Initialize realtime chart
        const chartData = {
            labels: [],
            cpu: [],
            memory: [],
            performance: []
        };

        setTimeout(() => {
            const isDark = document.body.classList.contains('dark-mode');
            const textColor = isDark ? '#f1f5f9' : '#0f172a';
            const gridColor = isDark ? '#334155' : '#e5e7eb';

            charts.system = new Chart(document.getElementById('systemChart'), {
                type: 'line',
                data: {
                    labels: chartData.labels,
                    datasets: [
                        {
                            label: 'CPU (%)',
                            data: chartData.cpu,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        },
                        {
                            label: 'Memória (%)',
                            data: chartData.memory,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        },
                        {
                            label: 'Performance (%)',
                            data: chartData.performance,
                            borderColor: '#f59e0b',
                            backgroundColor: 'rgba(245, 158, 11, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 750
                    },
                    plugins: {
                        legend: {
                            labels: { color: textColor }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: { color: gridColor },
                            ticks: { color: textColor }
                        },
                        x: {
                            grid: { display: false },
                            ticks: { color: textColor }
                        }
                    }
                }
            });
        }, 100);

        // Start monitoring
        startSystemMonitoring();

        // Add browser info to table
        thead.innerHTML = `
            <th>Propriedade</th>
            <th>Valor</th>
        `;

        const browserInfo = [
            { prop: 'Navegador', value: navigator.userAgent.split(' ').slice(-2).join(' ') },
            { prop: 'Plataforma', value: navigator.platform },
            { prop: 'Idioma', value: navigator.language },
            { prop: 'Online', value: navigator.onLine ? 'Sim' : 'Não' },
            { prop: 'Cookies Habilitados', value: navigator.cookieEnabled ? 'Sim' : 'Não' },
            { prop: 'Resolução da Tela', value: `${screen.width} x ${screen.height}` },
            { prop: 'Viewport', value: `${window.innerWidth} x ${window.innerHeight}` },
            { prop: 'Profundidade de Cor', value: screen.colorDepth + ' bits' },
            { prop: 'Núcleos do Processador', value: navigator.hardwareConcurrency || 'N/A' }
        ];

        browserInfo.forEach(info => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><strong>${info.prop}</strong></td>
                <td>${info.value}</td>
            `;
            tbody.appendChild(row);
        });
    }

    function startSystemMonitoring() {
        if (monitoringInterval) {
            clearInterval(monitoringInterval);
        }

        let timeIndex = 0;
        const maxPoints = 20;

        monitoringInterval = setInterval(() => {
            if (currentTab !== 'monitoring') {
                stopSystemMonitoring();
                return;
            }

            // Simulate system metrics (in real app, these would come from actual system APIs)
            systemStats.cpu = Math.random() * 60 + 20;
            systemStats.memory = Math.random() * 40 + 30;
            systemStats.performance = 100 - (systemStats.cpu + systemStats.memory) / 2;
            systemStats.fps = Math.floor(Math.random() * 10) + 55;
            systemStats.latency = Math.floor(Math.random() * 30) + 10;

            // Update UI
            const updateCard = (id, value, unit = '') => {
                const valueEl = document.getElementById(`${id}-value`);
                const progressEl = document.getElementById(`${id}-progress`);
                const statusEl = document.getElementById(`${id}-status`);

                if (valueEl) {
                    valueEl.textContent = `${Math.round(value)}${unit}`;
                }

                if (progressEl && !['fps', 'latency', 'experiments'].includes(id)) {
                    progressEl.style.width = `${Math.min(value, 100)}%`;
                }

                if (statusEl) {
                    let status = 'Normal';
                    let statusClass = 'status-healthy';

                    if (value > 80) {
                        status = 'Alto';
                        statusClass = 'status-critical';
                    } else if (value > 60) {
                        status = 'Moderado';
                        statusClass = 'status-warning';
                    }

                    statusEl.textContent = status;
                    statusEl.className = 'monitor-status ' + statusClass;
                }
            };

            updateCard('cpu', systemStats.cpu, '%');
            updateCard('memory', systemStats.memory, '%');
            updateCard('performance', systemStats.performance, '%');
            updateCard('fps', systemStats.fps, '');
            updateCard('latency', systemStats.latency, 'ms');
            updateCard('experiments', Object.keys(allExperiments).length, '');

            // Update chart
            if (charts.system) {
                const time = new Date().toLocaleTimeString();
                
                if (charts.system.data.labels.length >= maxPoints) {
                    charts.system.data.labels.shift();
                    charts.system.data.datasets[0].data.shift();
                    charts.system.data.datasets[1].data.shift();
                    charts.system.data.datasets[2].data.shift();
                }

                charts.system.data.labels.push(time);
                charts.system.data.datasets[0].data.push(systemStats.cpu);
                charts.system.data.datasets[1].data.push(systemStats.memory);
                charts.system.data.datasets[2].data.push(systemStats.performance);

                charts.system.update('none');
            }

            timeIndex++;
        }, 1000);
    }

    function stopSystemMonitoring() {
        if (monitoringInterval) {
            clearInterval(monitoringInterval);
            monitoringInterval = null;
        }
    }

    // ========== SETTINGS / CONFIGURAÇÕES ==========
    function renderSettings() {
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        const thead = document.querySelector('#metricsTable thead tr');
        
        statsGrid.innerHTML = '';
        container.innerHTML = '';
        tbody.innerHTML = '';
        thead.innerHTML = '';

        // Create settings container
        const settingsDiv = document.createElement('div');
        settingsDiv.className = 'settings-container';
        settingsDiv.style.gridColumn = '1 / -1';

        // Appearance Settings
        const appearanceSection = createSettingsSection(
            'fa-palette',
            'Aparência',
            [
                {
                    title: 'Modo Escuro',
                    description: 'Ativar tema escuro para reduzir o brilho da tela',
                    control: `
                        <label class="switch">
                            <input type="checkbox" id="darkModeToggle" ${isDarkMode ? 'checked' : ''} onchange="toggleDarkMode()">
                            <span class="slider"></span>
                        </label>
                    `
                },
                {
                    title: 'Esquema de Cores dos Gráficos',
                    description: 'Escolha o esquema de cores para todos os gráficos',
                    control: `<div id="colorSchemeSelector"></div>`
                }
            ]
        );

        // Chart Settings
        const chartSection = createSettingsSection(
            'fa-chart-line',
            'Gráficos',
            [
                {
                    title: 'Mostrar Legenda',
                    description: 'Exibir legendas nos gráficos',
                    control: `
                        <label class="switch">
                            <input type="checkbox" id="legendToggle" ${chartSettings.showLegend ? 'checked' : ''} onchange="toggleChartLegend()">
                            <span class="slider"></span>
                        </label>
                    `
                },
                {
                    title: 'Linhas de Grade',
                    description: 'Mostrar linhas de grade de fundo',
                    control: `
                        <label class="switch">
                            <input type="checkbox" id="gridToggle" ${chartSettings.showGridLines ? 'checked' : ''} onchange="toggleGridLines()">
                            <span class="slider"></span>
                        </label>
                    `
                },
                {
                    title: 'Animações',
                    description: 'Ativar animações ao carregar gráficos',
                    control: `
                        <label class="switch">
                            <input type="checkbox" id="animationToggle" ${chartSettings.animationEnabled ? 'checked' : ''} onchange="toggleAnimations()">
                            <span class="slider"></span>
                        </label>
                    `
                },
                {
                    title: 'Qualidade de Exportação',
                    description: 'Definir qualidade para exportação de imagens e PDF',
                    control: `
                        <select class="select-custom" id="exportQuality" onchange="changeExportQuality(this.value)">
                            <option value="low" ${chartSettings.exportQuality === 'low' ? 'selected' : ''}>Baixa (Rápido)</option>
                            <option value="medium" ${chartSettings.exportQuality === 'medium' ? 'selected' : ''}>Média</option>
                            <option value="high" ${chartSettings.exportQuality === 'high' ? 'selected' : ''}>Alta (Recomendado)</option>
                            <option value="ultra" ${chartSettings.exportQuality === 'ultra' ? 'selected' : ''}>Ultra (Lento)</option>
                        </select>
                    `
                }
            ]
        );

        // Data Settings
        const dataSection = createSettingsSection(
            'fa-database',
            'Dados',
            [
                {
                    title: 'Total de Experimentos',
                    description: 'Número de experimentos carregados atualmente',
                    control: `<span style="font-weight: 700; color: var(--primary);">${Object.keys(allExperiments).length}</span>`
                },
                {
                    title: 'Limpar Todos os Dados',
                    description: 'Remover todos os experimentos e começar do zero',
                    control: `<button class="btn btn-danger" onclick="resetDashboard()">Limpar Dados</button>`
                },
                {
                    title: 'Exportar Todos',
                    description: 'Exportar todos os experimentos como arquivo JSON',
                    control: `<button class="btn btn-primary" onclick="exportAllExperiments()">Exportar Tudo</button>`
                }
            ]
        );

        // Performance Settings
        const performanceSection = createSettingsSection(
            'fa-tachometer-alt',
            'Performance',
            [
                {
                    title: 'Atualização em Tempo Real',
                    description: 'Velocidade de atualização do monitoramento (requer recarregar aba)',
                    control: `
                        <select class="select-custom" id="monitoringSpeed">
                            <option value="500">0.5s (Rápido)</option>
                            <option value="1000" selected>1s (Normal)</option>
                            <option value="2000">2s (Lento)</option>
                            <option value="5000">5s (Muito Lento)</option>
                        </select>
                    `
                }
            ]
        );

        settingsDiv.innerHTML = appearanceSection + chartSection + dataSection + performanceSection;
        container.appendChild(settingsDiv);

        // Render color schemes
        setTimeout(() => {
            renderColorSchemes();
        }, 100);
    }

    function createSettingsSection(icon, title, options) {
        let optionsHtml = '';
        
        options.forEach(opt => {
            optionsHtml += `
                <div class="settings-option">
                    <div class="option-label">
                        <div class="option-title">${opt.title}</div>
                        <div class="option-description">${opt.description}</div>
                    </div>
                    <div class="option-control">
                        ${opt.control}
                    </div>
                </div>
            `;
        });

        return `
            <div class="settings-section">
                <div class="settings-title">
                    <i class="fas ${icon}"></i>
                    ${title}
                </div>
                ${optionsHtml}
            </div>
        `;
    }

    function renderColorSchemes() {
        const container = document.getElementById('colorSchemeSelector');
        if (!container) return;

        const schemesHtml = `
            <div class="color-scheme-grid">
                ${Object.entries(colorSchemes).map(([key, scheme]) => `
                    <div class="scheme-card ${chartSettings.colorScheme === key ? 'active' : ''}" onclick="applyColorScheme('${key}')">
                        <div class="scheme-colors">
                            ${scheme.colors.slice(0, 5).map(color => `
                                <div class="scheme-color" style="background: ${color};"></div>
                            `).join('')}
                        </div>
                        <div class="scheme-name">${scheme.name}</div>
                    </div>
                `).join('')}
            </div>
        `;

        container.innerHTML = schemesHtml;
    }

    function applyColorScheme(schemeName) {
        chartSettings.colorScheme = schemeName;
        const scheme = colorSchemes[schemeName];
        
        if (scheme) {
            chartSettings.colors.primary = scheme.colors[0];
            chartSettings.colors.secondary = scheme.colors[1];
            chartSettings.colors.success = scheme.colors[2];
            chartSettings.colors.warning = scheme.colors[3];
            chartSettings.colors.danger = scheme.colors[4];
            chartSettings.colors.info = scheme.colors[5] || scheme.colors[0];
        }

        // Update UI
        document.querySelectorAll('.scheme-card').forEach(card => {
            card.classList.remove('active');
        });
        event.target.closest('.scheme-card')?.classList.add('active');

        // Refresh charts with new colors
        if (currentExperiment && currentTab !== 'settings' && currentTab !== 'monitoring') {
            renderDashboard();
        }

        showNotification(`Esquema de cores "${scheme.name}" aplicado!`, 'success');
    }

    function toggleChartLegend() {
        chartSettings.showLegend = !chartSettings.showLegend;
        if (currentExperiment) renderDashboard();
        showNotification(`Legenda ${chartSettings.showLegend ? 'ativada' : 'desativada'}`, 'info');
    }

    function toggleGridLines() {
        chartSettings.showGridLines = !chartSettings.showGridLines;
        if (currentExperiment) renderDashboard();
        showNotification(`Linhas de grade ${chartSettings.showGridLines ? 'ativadas' : 'desativadas'}`, 'info');
    }

    function toggleAnimations() {
        chartSettings.animationEnabled = !chartSettings.animationEnabled;
        if (currentExperiment) renderDashboard();
        showNotification(`Animações ${chartSettings.animationEnabled ? 'ativadas' : 'desativadas'}`, 'info');
    }

    function changeExportQuality(quality) {
        chartSettings.exportQuality = quality;
        showNotification(`Qualidade de exportação definida como: ${quality}`, 'info');
    }

    // ========== CHART CUSTOMIZATION FUNCTIONS ==========
    function changeChartType(chartName, newType) {
        chartSettings.chartType[chartName] = newType;
        if (currentExperiment) {
            renderDashboard();
        }
        showNotification(`Tipo de gráfico alterado para: ${newType}`, 'info');
    }

    function addChartControls(chartCard, chartName) {
        const header = chartCard.querySelector('.chart-header');
        if (!header) return;

        const controls = document.createElement('div');
        controls.className = 'chart-controls';
        controls.innerHTML = `
            <button class="control-btn ${chartSettings.chartType[chartName] === 'bar' ? 'active' : ''}" 
                    onclick="changeChartType('${chartName}', 'bar')">
                <i class="fas fa-chart-bar"></i>
                Barras
            </button>
            <button class="control-btn ${chartSettings.chartType[chartName] === 'line' ? 'active' : ''}" 
                    onclick="changeChartType('${chartName}', 'line')">
                <i class="fas fa-chart-line"></i>
                Linha
            </button>
            <button class="control-btn ${chartSettings.chartType[chartName] === 'radar' ? 'active' : ''}" 
                    onclick="changeChartType('${chartName}', 'radar')">
                <i class="fas fa-chart-area"></i>
                Radar
            </button>
            <button class="control-btn" onclick="downloadChart('${chartName}')">
                <i class="fas fa-download"></i>
                Download
            </button>
        `;

        header.appendChild(controls);
    }

    async function downloadChart(chartName) {
        const canvas = document.getElementById(chartName + 'Chart');
        if (!canvas) {
            showNotification('Gráfico não encontrado', 'error');
            return;
        }

        try {
            const link = document.createElement('a');
            link.download = `${chartName}_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            showNotification('Gráfico baixado com sucesso!', 'success');
        } catch (error) {
            console.error('Erro ao baixar gráfico:', error);
            showNotification('Erro ao baixar gráfico', 'error');
        }
    }

    // Mobile responsiveness
    if (window.innerWidth < 1024) {
        document.getElementById('sidebar').classList.add('collapsed');
        document.getElementById('mainContent').classList.add('expanded');
        isSidebarOpen = false;
    }
</script>
</body>
</html><!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SynDataGen - Advanced Analytics Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #3b82f6;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #06b6d4;
            --dark: #1f2937;
            --light: #f9fafb;
            --sidebar-width: 280px;
            --navbar-height: 64px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', 'Roboto', sans-serif;
            background: #f9fafb;
            color: #1f2937;
            transition: all 0.3s ease;
        }

        body.dark-mode {
            background: #0f172a;
            color: #f8fafc;
        }

        /* Top Navbar - FIXED */
        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--navbar-height);
            background: white;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            padding: 0 2rem;
            z-index: 1000;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        body.dark-mode .navbar {
            background: #1e293b;
            border-bottom-color: #334155;
        }

        .nav-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .nav-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .menu-toggle {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: inherit;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: background 0.2s;
        }

        .menu-toggle:hover {
            background: rgba(0,0,0,0.05);
        }

        body.dark-mode .menu-toggle:hover {
            background: rgba(255,255,255,0.1);
        }

        .logo {
            font-size: 1.25rem;
            font-weight: 900;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .logo i {
            font-size: 1.5rem;
        }

        .nav-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .nav-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            color: inherit;
            font-size: 1.125rem;
            transition: all 0.2s;
            position: relative;
        }

        .nav-btn:hover {
            background: rgba(0,0,0,0.05);
        }

        body.dark-mode .nav-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .nav-badge {
            position: absolute;
            top: 0;
            right: 0;
            background: var(--danger);
            color: white;
            font-size: 0.65rem;
            padding: 0.125rem 0.375rem;
            border-radius: 9999px;
            font-weight: 600;
        }

        /* Sidebar - FIXED */
        .sidebar {
            position: fixed;
            left: 0;
            top: var(--navbar-height);
            width: var(--sidebar-width);
            height: calc(100vh - var(--navbar-height));
            background: white;
            border-right: 1px solid #e5e7eb;
            overflow-y: auto;
            transition: transform 0.3s ease;
            z-index: 999;
        }

        body.dark-mode .sidebar {
            background: #1e293b;
            border-right-color: #334155;
        }

        .sidebar.collapsed {
            transform: translateX(-100%);
        }

        .sidebar-section {
            padding: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
        }

        body.dark-mode .sidebar-section {
            border-bottom-color: #334155;
        }

        .sidebar-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            color: #9ca3af;
            margin-bottom: 1rem;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .experiment-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .experiment-item {
            padding: 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            display: flex;
            flex-direction: column;
        }

        body.dark-mode .experiment-item {
            background: #0f172a;
            border-color: #334155;
        }

        .experiment-item:hover {
            border-color: var(--primary);
            transform: translateX(4px);
        }

        .experiment-item.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-color: var(--primary);
            color: white;
        }

        .experiment-action-btn {
            background: rgba(0, 0, 0, 0.05);
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            color: inherit;
        }

        .experiment-action-btn:hover {
            background: rgba(0, 0, 0, 0.1);
            transform: scale(1.1);
        }

        .experiment-item.active .experiment-action-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .experiment-item.active .experiment-action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        body.dark-mode .experiment-action-btn {
            background: rgba(255, 255, 255, 0.05);
        }

        body.dark-mode .experiment-action-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .experiment-name {
            font-weight: 700;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .experiment-meta {
            display: flex;
            gap: 0.75rem;
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .experiment-item.active .experiment-meta {
            opacity: 1;
        }

        .meta-badge {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .quick-actions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .action-btn {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            color: inherit;
            text-decoration: none;
        }

        body.dark-mode .action-btn {
            background: #0f172a;
            border-color: #334155;
        }

        .action-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Main Content */
        .main-content {
            margin-left: var(--sidebar-width);
            margin-top: var(--navbar-height);
            padding: 2rem;
            min-height: calc(100vh - var(--navbar-height));
            transition: margin-left 0.3s ease;
        }

        .main-content.expanded {
            margin-left: 0;
        }

        /* Upload Section */
        .upload-section {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 70vh;
        }

        .upload-container {
            text-align: center;
            max-width: 600px;
            padding: 3rem;
        }

        .upload-icon {
            font-size: 4rem;
            color: var(--primary);
            margin-bottom: 1.5rem;
        }

        .upload-title {
            font-size: 2rem;
            font-weight: 900;
            margin-bottom: 1rem;
        }

        .upload-subtitle {
            font-size: 1.125rem;
            color: #6b7280;
            margin-bottom: 2rem;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem 2rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-radius: 0.75rem;
            cursor: pointer;
            font-weight: 700;
            font-size: 1.125rem;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }

        /* Dashboard Content */
        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .header-left h1 {
            font-size: 2rem;
            font-weight: 900;
            margin-bottom: 0.5rem;
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #6b7280;
            font-size: 0.875rem;
        }

        .header-actions {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            font-size: 0.875rem;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: white;
            color: var(--dark);
            border: 1px solid #e5e7eb;
        }

        body.dark-mode .btn-secondary {
            background: #1e293b;
            color: white;
            border-color: #334155;
        }

        .btn-secondary:hover {
            background: #f3f4f6;
        }

        body.dark-mode .btn-secondary:hover {
            background: #334155;
        }

        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: white;
            padding: 1.5rem;
            border-radius: 1rem;
            border: 1px solid #e5e7eb;
            transition: all 0.3s;
        }

        body.dark-mode .stat-card {
            background: #1e293b;
            border-color: #334155;
        }

        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.1);
        }

        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .stat-icon {
            width: 48px;
            height: 48px;
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 900;
            margin-bottom: 0.25rem;
        }

        .stat-label {
            color: #6b7280;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .stat-trend {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.875rem;
            font-weight: 600;
            margin-top: 0.5rem;
        }

        .trend-up {
            color: var(--success);
        }

        .trend-down {
            color: var(--danger);
        }

        /* Chart Section */
        .chart-section {
            margin-bottom: 2rem;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 800;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .section-actions {
            display: flex;
            gap: 0.5rem;
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        body.dark-mode .icon-btn {
            background: #1e293b;
            border-color: #334155;
        }

        .icon-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 1.5rem;
        }

        .chart-card {
            background: white;
            padding: 1.5rem;
            border-radius: 1rem;
            border: 1px solid #e5e7eb;
        }

        body.dark-mode .chart-card {
            background: #1e293b;
            border-color: #334155;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .chart-title {
            font-weight: 700;
            font-size: 1.125rem;
        }

        .chart-container {
            position: relative;
            height: 300px;
        }

        /* Metrics Table */
        .table-container {
            background: white;
            border-radius: 1rem;
            border: 1px solid #e5e7eb;
            overflow: hidden;
            margin-bottom: 2rem;
        }

        body.dark-mode .table-container {
            background: #1e293b;
            border-color: #334155;
        }

        .table-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        body.dark-mode .table-header {
            border-bottom-color: #334155;
        }

        .table-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .search-box {
            position: relative;
        }

        .search-input {
            padding: 0.5rem 1rem 0.5rem 2.5rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            width: 250px;
            background: white;
            color: inherit;
        }

        body.dark-mode .search-input {
            background: #0f172a;
            border-color: #334155;
        }

        .search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: #9ca3af;
        }

        .filter-select {
            padding: 0.5rem 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            background: white;
            color: inherit;
            cursor: pointer;
        }

        body.dark-mode .filter-select {
            background: #0f172a;
            border-color: #334155;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: #f9fafb;
        }

        body.dark-mode thead {
            background: #0f172a;
        }

        th {
            padding: 1rem 1.5rem;
            text-align: left;
            font-weight: 700;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #6b7280;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            background: #f3f4f6;
        }

        body.dark-mode th:hover {
            background: #1e293b;
        }

        td {
            padding: 1rem 1.5rem;
            border-top: 1px solid #e5e7eb;
            font-size: 0.875rem;
        }

        body.dark-mode td {
            border-top-color: #334155;
        }

        tr:hover {
            background: #f9fafb;
        }

        body.dark-mode tr:hover {
            background: #0f172a;
        }

        .metric-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-weight: 600;
            font-size: 0.75rem;
        }

        .badge-success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
        }

        .badge-warning {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning);
        }

        .badge-danger {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            border-bottom: 2px solid #e5e7eb;
            margin-bottom: 2rem;
        }

        body.dark-mode .tabs {
            border-bottom-color: #334155;
        }

        .tab {
            padding: 1rem 1.5rem;
            cursor: pointer;
            font-weight: 600;
            color: #6b7280;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tab:hover {
            color: var(--primary);
        }

        .tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .main-content {
                margin-left: 0;
            }

            .chart-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .navbar {
                padding: 0 1rem;
            }

            .main-content {
                padding: 1rem;
            }

            .dashboard-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .search-input {
                width: 100%;
            }

            .table-controls {
                flex-direction: column;
                width: 100%;
            }
        }

        /* Loading Animation */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e5e7eb;
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tooltips */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #1f2937;
            color: white;
            text-align: center;
            border-radius: 0.5rem;
            padding: 0.5rem;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 5rem;
            right: 1rem;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .toast {
            background: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            min-width: 300px;
            animation: slideIn 0.3s ease-out;
        }

        body.dark-mode .toast {
            background: #1e293b;
        }

        .toast.success {
            border-left: 4px solid var(--success);
        }

        .toast.error {
            border-left: 4px solid var(--danger);
        }

        .toast.warning {
            border-left: 4px solid var(--warning);
        }

        .toast.info {
            border-left: 4px solid var(--info);
        }

        .toast-icon {
            font-size: 1.25rem;
        }

        .toast.success .toast-icon {
            color: var(--success);
        }

        .toast.error .toast-icon {
            color: var(--danger);
        }

        .toast.warning .toast-icon {
            color: var(--warning);
        }

        .toast.info .toast-icon {
            color: var(--info);
        }

        .toast-message {
            flex: 1;
            font-size: 0.875rem;
        }

        .toast-close {
            background: none;
            border: none;
            cursor: pointer;
            color: inherit;
            opacity: 0.5;
            font-size: 1.25rem;
        }

        .toast-close:hover {
            opacity: 1;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Top Navbar -->
    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <button class="menu-toggle" id="menuToggle" onclick="toggleSidebar()">
                    <i class="fas fa-bars"></i>
                </button>
                <div class="logo">
                    <i class="fas fa-chart-line"></i>
                    <span>SynDataGen</span>
                </div>
            </div>
            <div class="nav-right">
                <button class="nav-btn" onclick="refreshExperiment()" title="Atualizar">
                    <i class="fas fa-sync-alt"></i>
                </button>
                <button class="nav-btn" onclick="showNotificationsCenter()" title="Notificações">
                    <i class="fas fa-bell"></i>
                    <span class="nav-badge">3</span>
                </button>
                <button class="nav-btn" onclick="toggleTheme()" title="Alternar Tema">
                    <i class="fas fa-moon" id="themeIcon"></i>
                </button>
                <button class="nav-btn" onclick="showSettings()" title="Configurações">
                    <i class="fas fa-cog"></i>
                </button>
            </div>
        </div>
    </nav>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">
                <i class="fas fa-flask"></i>
                Experimentos
                <span id="totalExperiments" style="margin-left: auto; background: var(--primary); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.7rem;">0</span>
            </div>
            <div class="experiment-list" id="experimentList">
                <!-- Experiments will be populated here -->
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">
                <i class="fas fa-bolt"></i>
                Ações Rápidas
            </div>
            <div class="quick-actions">
                <button class="action-btn" onclick="document.getElementById('fileInput').click()">
                    <i class="fas fa-upload"></i>
                    Carregar Mais JSONs
                </button>
                <button class="action-btn" onclick="exportCurrentExperiment()">
                    <i class="fas fa-download"></i>
                    Exportar CSV
                </button>
                <button class="action-btn" onclick="compareExperiments()">
                    <i class="fas fa-columns"></i>
                    Comparar Experimentos
                </button>
                <button class="action-btn" onclick="generateReport()">
                    <i class="fas fa-file-alt"></i>
                    Gerar Relatório
                </button>
                <button class="action-btn" onclick="exportAllExperiments()">
                    <i class="fas fa-file-archive"></i>
                    Exportar Todos
                </button>
                <button class="action-btn" onclick="resetDashboard()">
                    <i class="fas fa-redo"></i>
                    Limpar Tudo
                </button>
            </div>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content" id="mainContent">
        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <div class="upload-container">
                <div class="upload-icon">
                    <i class="fas fa-cloud-upload-alt"></i>
                </div>
                <h1 class="upload-title">Carregue seus experimentos</h1>
                <p class="upload-subtitle">
                    Arraste e solte um arquivo JSON ou clique para selecionar
                </p>
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" class="file-input" accept=".json" multiple onchange="handleFileUpload(event)">
                    <label for="fileInput" class="file-input-label">
                        <i class="fas fa-folder-open"></i>
                        Selecionar Arquivos JSON
                    </label>
                </div>
                <p style="margin-top: 1rem; color: #6b7280; font-size: 0.875rem;">
                    <i class="fas fa-info-circle"></i> Você pode selecionar múltiplos arquivos
                </p>
            </div>
        </div>

        <!-- Dashboard Content (Hidden by default) -->
        <div id="dashboardContent" style="display: none;">
            <!-- Header -->
            <div class="dashboard-header">
                <div class="header-left">
                    <h1 id="experimentTitle">Dashboard de Experimentos</h1>
                    <div class="breadcrumb">
                        <i class="fas fa-home"></i>
                        <span>/</span>
                        <span id="breadcrumbPath">Dashboard</span>
                    </div>
                </div>
                <div class="header-actions">
                    <button class="btn btn-secondary" onclick="exportAsPDF()">
                        <i class="fas fa-file-pdf"></i>
                        Exportar PDF
                    </button>
                    <button class="btn btn-primary" onclick="shareExperiment()">
                        <i class="fas fa-share-alt"></i>
                        Compartilhar
                    </button>
                </div>
            </div>

            <!-- Tabs -->
            <div class="tabs" id="metricsTabs">
                <div class="tab active" onclick="switchTab('classification')">
                    <i class="fas fa-chart-bar"></i>
                    Classificação
                </div>
                <div class="tab" onclick="switchTab('distance')">
                    <i class="fas fa-ruler"></i>
                    Distâncias
                </div>
                <div class="tab" onclick="switchTab('efficiency')">
                    <i class="fas fa-tachometer-alt"></i>
                    Eficiência
                </div>
                <div class="tab" onclick="switchTab('sdv')">
                    <i class="fas fa-check-circle"></i>
                    SDV Metrics
                </div>
                <div class="tab" onclick="switchTab('arguments')">
                    <i class="fas fa-cog"></i>
                    Argumentos
                </div>
            </div>

            <!-- Stats Cards -->
            <div class="stats-grid" id="statsGrid">
                <!-- Stats will be populated dynamically -->
            </div>

            <!-- Charts Section -->
            <div class="chart-section">
                <div class="section-header">
                    <h2 class="section-title">
                        <i class="fas fa-chart-area"></i>
                        Visualizações
                    </h2>
                    <div class="section-actions">
                        <button class="icon-btn" onclick="refreshCharts()" title="Atualizar Gráficos">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        <button class="icon-btn" onclick="downloadCharts()" title="Baixar Gráficos">
                            <i class="fas fa-download"></i>
                        </button>
                    </div>
                </div>
                <div class="chart-grid" id="chartsContainer">
                    <!-- Charts will be populated dynamically -->
                </div>
            </div>

            <!-- Metrics Table -->
            <div class="table-container">
                <div class="table-header">
                    <h3 class="section-title">
                        <i class="fas fa-table"></i>
                        Métricas Detalhadas
                    </h3>
                    <div class="table-controls">
                        <div class="search-box">
                            <i class="fas fa-search search-icon"></i>
                            <input type="text" class="search-input" placeholder="Buscar modelo..." onkeyup="filterTable(this.value)">
                        </div>
                        <select class="filter-select" onchange="filterByMetric(this.value)">
                            <option value="all">Todos os Modelos</option>
                            <option value="high">Alta Performance (>70%)</option>
                            <option value="medium">Média Performance (50-70%)</option>
                            <option value="low">Baixa Performance (<50%)</option>
                        </select>
                    </div>
                </div>
                <div style="overflow-x: auto;">
                    <table id="metricsTable">
                        <thead>
                            <tr>
                                <th onclick="sortTable(0)">Modelo <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(1)">Fold <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(2)">Accuracy <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(3)">F1-Score <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(4)">Precision <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(5)">Recall <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(6)">MSE <i class="fas fa-sort"></i></th>
                                <th onclick="sortTable(7)">MAE <i class="fas fa-sort"></i></th>
                            </tr>
                        </thead>
                        <tbody id="metricsTableBody">
                            <!-- Table rows will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </main>

<script>
    let allExperiments = {};
    let experimentMetadata = {};
    let currentExperiment = null;
    let currentTab = 'classification';
    let charts = {};
    let isDarkMode = false;
    let isSidebarOpen = true;
    let comparisonMode = false;

    // Helper function to extract value (handles both direct values and {mean, std} objects)
    function getValue(val, defaultValue = 0) {
        if (val === null || val === undefined) return defaultValue;
        if (typeof val === 'object' && val.mean !== undefined) {
            return val.mean;
        }
        return val;
    }

    // Handle file upload
    function handleFileUpload(event) {
        const files = event.target.files;
        console.log('Files selected:', files.length);
        if (!files || files.length === 0) return;

        let filesProcessed = 0;
        let filesWithErrors = [];
        const totalFiles = files.length;

        Array.from(files).forEach(file => {
            console.log('Processing file:', file.name);
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    console.log('Parsing JSON for:', file.name);
                    const data = JSON.parse(e.target.result);
                    let experimentName = file.name.replace('.json', '');
                    
                    // Check if experiment already exists
                    if (allExperiments[experimentName]) {
                        const timestamp = new Date().getTime();
                        experimentName = `${experimentName}_${timestamp}`;
                    }
                    
                    console.log('Storing experiment:', experimentName);
                    // Store experiment
                    allExperiments[experimentName] = data;
                    
                    // Extract metadata
                    experimentMetadata[experimentName] = {
                        modelType: data.Arguments?.model_type || 'unknown',
                        numFolds: extractNumFolds(data),
                        timestamp: new Date().toISOString(),
                        originalName: file.name.replace('.json', '')
                    };
                    
                    console.log('Adding to sidebar:', experimentName);
                    // Add to sidebar
                    addExperimentToSidebar(experimentName);
                    
                    filesProcessed++;
                    console.log(`Files processed: ${filesProcessed}/${totalFiles}`);
                    
                    // After all files are processed
                    if (filesProcessed === totalFiles) {
                        console.log('All files processed, showing dashboard');
                        // Update counter
                        document.getElementById('totalExperiments').textContent = Object.keys(allExperiments).length;
                        
                        // Show dashboard
                        document.getElementById('uploadSection').style.display = 'none';
                        document.getElementById('dashboardContent').style.display = 'block';
                        
                        // Select the first experiment if none selected
                        if (!currentExperiment) {
                            const firstExperiment = Object.keys(allExperiments)[0];
                            console.log('Selecting first experiment:', firstExperiment);
                            if (firstExperiment) {
                                selectExperiment(firstExperiment);
                            }
                        }
                        
                        if (filesWithErrors.length > 0) {
                            showNotification(`${filesProcessed - filesWithErrors.length} arquivo(s) carregado(s). ${filesWithErrors.length} com erro.`, 'warning');
                        } else {
                            showNotification(`${filesProcessed} arquivo(s) carregado(s) com sucesso!`, 'success');
                        }
                    }
                    
                } catch (error) {
                    console.error(`Erro ao carregar ${file.name}:`, error);
                    filesWithErrors.push(file.name);
                    filesProcessed++;
                    
                    if (filesProcessed === totalFiles) {
                        if (filesWithErrors.length === totalFiles) {
                            showNotification('Erro ao carregar todos os arquivos. Verifique o formato.', 'error');
                        } else {
                            document.getElementById('uploadSection').style.display = 'none';
                            document.getElementById('dashboardContent').style.display = 'block';
                            document.getElementById('totalExperiments').textContent = Object.keys(allExperiments).length;
                            
                            if (!currentExperiment && Object.keys(allExperiments).length > 0) {
                                selectExperiment(Object.keys(allExperiments)[0]);
                            }
                            
                            showNotification(`${filesProcessed - filesWithErrors.length} arquivo(s) carregado(s). ${filesWithErrors.length} com erro.`, 'warning');
                        }
                    }
                }
            };
            
            reader.onerror = function() {
                console.error(`Erro ao ler arquivo ${file.name}`);
                filesWithErrors.push(file.name);
                filesProcessed++;
                
                if (filesProcessed === totalFiles) {
                    if (filesWithErrors.length === totalFiles) {
                        showNotification('Erro ao ler todos os arquivos', 'error');
                    } else {
                        document.getElementById('uploadSection').style.display = 'none';
                        document.getElementById('dashboardContent').style.display = 'block';
                        showNotification(`${filesProcessed - filesWithErrors.length} arquivo(s) carregado(s)`, 'success');
                    }
                }
            };
            
            reader.readAsText(file);
        });
        
        // Clear the file input so the same file can be selected again
        event.target.value = '';
    }

    function extractNumFolds(data) {
        // Try ClassificationMetrics first
        if (data.ClassificationMetrics) {
            const models = Object.values(data.ClassificationMetrics);
            if (models.length > 0) {
                const folds = Object.keys(models[0]).filter(k => k.includes('Fold') && !k.includes('Summary'));
                return folds.length;
            }
        }
        
        // Try EfficiencyMetrics
        if (data.EfficiencyMetrics) {
            const folds = Object.keys(data.EfficiencyMetrics).filter(k => k.includes('Fold') && !k.includes('Summary'));
            return folds.length;
        }
        
        // Try Arguments
        if (data.Arguments && data.Arguments.number_k_folds) {
            return data.Arguments.number_k_folds;
        }
        
        return 0;
    }

    function addExperimentToSidebar(name) {
        console.log('Adding experiment to sidebar:', name);
        const list = document.getElementById('experimentList');
        const metadata = experimentMetadata[name];
        console.log('Metadata:', metadata);
        
        const item = document.createElement('div');
        item.className = 'experiment-item';
        item.dataset.experimentName = name;
        
        // Main content (clickable)
        const mainContent = document.createElement('div');
        mainContent.style.flex = '1';
        mainContent.onclick = () => selectExperiment(name);
        mainContent.innerHTML = `
            <div class="experiment-name">
                <i class="fas fa-database"></i>
                ${metadata.originalName || name}
            </div>
            <div class="experiment-meta">
                <span class="meta-badge">
                    <i class="fas fa-layer-group"></i>
                    ${metadata.modelType}
                </span>
                <span class="meta-badge">
                    <i class="fas fa-folder"></i>
                    ${metadata.numFolds} Folds
                </span>
            </div>
        `;
        
        // Actions (not clickable for selection)
        const actions = document.createElement('div');
        actions.className = 'experiment-actions';
        actions.style.cssText = 'display: flex; gap: 0.25rem; margin-top: 0.5rem;';
        actions.innerHTML = `
            <button class="experiment-action-btn" onclick="event.stopPropagation(); removeExperiment('${name}')" title="Remover">
                <i class="fas fa-trash"></i>
            </button>
            <button class="experiment-action-btn" onclick="event.stopPropagation(); duplicateExperiment('${name}')" title="Duplicar">
                <i class="fas fa-copy"></i>
            </button>
            <button class="experiment-action-btn" onclick="event.stopPropagation(); downloadExperiment('${name}')" title="Baixar">
                <i class="fas fa-download"></i>
            </button>
        `;
        
        item.appendChild(mainContent);
        item.appendChild(actions);
        list.appendChild(item);
        console.log('Experiment added to sidebar successfully');
    }

    function selectExperiment(name) {
        console.log('Selecting experiment:', name);
        currentExperiment = name;
        
        // Update active state
        document.querySelectorAll('.experiment-item').forEach(item => {
            item.classList.remove('active');
            if (item.dataset.experimentName === name) {
                item.classList.add('active');
            }
        });

        // Update breadcrumb
        const displayName = experimentMetadata[name]?.originalName || name;
        document.getElementById('experimentTitle').textContent = displayName;
        document.getElementById('breadcrumbPath').textContent = `Dashboard / ${displayName}`;

        console.log('Rendering dashboard for:', name);
        // Render dashboard
        renderDashboard();
    }

    function removeExperiment(name) {
        if (confirm(`Deseja remover o experimento "${experimentMetadata[name]?.originalName || name}"?`)) {
            // Remove from data structures
            delete allExperiments[name];
            delete experimentMetadata[name];
            
            // Remove from sidebar
            const item = document.querySelector(`.experiment-item[data-experiment-name="${name}"]`);
            if (item) {
                item.remove();
            }
            
            // Update counter
            document.getElementById('totalExperiments').textContent = Object.keys(allExperiments).length;
            
            // If it was the current experiment, select another or show upload section
            if (currentExperiment === name) {
                const remainingExperiments = Object.keys(allExperiments);
                if (remainingExperiments.length > 0) {
                    selectExperiment(remainingExperiments[0]);
                } else {
                    currentExperiment = null;
                    document.getElementById('uploadSection').style.display = 'block';
                    document.getElementById('dashboardContent').style.display = 'none';
                }
            }
            
            showNotification('Experimento removido com sucesso', 'success');
        }
    }

    function duplicateExperiment(name) {
        const timestamp = new Date().getTime();
        const newName = `${name}_copy_${timestamp}`;
        
        // Deep clone the data
        allExperiments[newName] = JSON.parse(JSON.stringify(allExperiments[name]));
        
        // Clone metadata
        experimentMetadata[newName] = {
            ...experimentMetadata[name],
            originalName: (experimentMetadata[name]?.originalName || name) + ' (cópia)',
            timestamp: new Date().toISOString()
        };
        
        // Add to sidebar
        addExperimentToSidebar(newName);
        
        // Update counter
        document.getElementById('totalExperiments').textContent = Object.keys(allExperiments).length;
        
        // Select the new experiment
        selectExperiment(newName);
        
        showNotification('Experimento duplicado com sucesso', 'success');
    }

    function downloadExperiment(name) {
        const data = allExperiments[name];
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${experimentMetadata[name]?.originalName || name}.json`;
        a.click();
        window.URL.revokeObjectURL(url);
        
        showNotification('Download iniciado', 'success');
    }

    function showNotification(message, type = 'info') {
        const container = document.getElementById('toastContainer');
        
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icons = {
            success: 'fa-check-circle',
            error: 'fa-exclamation-circle',
            warning: 'fa-exclamation-triangle',
            info: 'fa-info-circle'
        };
        
        toast.innerHTML = `
            <i class="fas ${icons[type]} toast-icon"></i>
            <span class="toast-message">${message}</span>
            <button class="toast-close" onclick="this.parentElement.remove()">
                <i class="fas fa-times"></i>
            </button>
        `;
        
        container.appendChild(toast);
        
        // Auto remove after 5 seconds
        setTimeout(() => {
            toast.remove();
        }, 5000);
    }

    function switchTab(tabName) {
        currentTab = tabName;
        
        // Update active tab
        document.querySelectorAll('.tab').forEach(tab => {
            tab.classList.remove('active');
        });
        event.target.closest('.tab').classList.add('active');

        // Re-render dashboard based on tab
        renderDashboard();
    }

    function renderDashboard() {
        console.log('renderDashboard called for:', currentExperiment, 'tab:', currentTab);
        if (!currentExperiment) {
            console.warn('No current experiment selected');
            return;
        }

        const data = allExperiments[currentExperiment];
        console.log('Experiment data:', data);
        
        switch(currentTab) {
            case 'classification':
                console.log('Rendering classification metrics');
                renderClassificationMetrics(data);
                break;
            case 'distance':
                console.log('Rendering distance metrics');
                renderDistanceMetrics(data);
                break;
            case 'efficiency':
                console.log('Rendering efficiency metrics');
                renderEfficiencyMetrics(data);
                break;
            case 'sdv':
                console.log('Rendering SDV metrics');
                renderSDVMetrics(data);
                break;
            case 'arguments':
                console.log('Rendering arguments');
                renderArguments(data);
                break;
        }
    }

    function renderClassificationMetrics(data) {
        // Check for classification data in various evaluation sections
        const evaluationSections = ['TS-TR', 'TR-TS', 'TR-TR'];
        let classificationData = null;
        
        // Try to find data in evaluation sections first
        for (const section of evaluationSections) {
            if (data[section]) {
                classificationData = data[section];
                break;
            }
        }
        
        // Fallback to ClassificationMetrics if it exists
        if (!classificationData && data.ClassificationMetrics) {
            classificationData = data.ClassificationMetrics;
        }
        
        if (!classificationData) {
            showNoDataMessage();
            return;
        }

        // Render stats cards
        renderClassificationStats(classificationData);
        
        // Render charts
        renderClassificationCharts(classificationData);
        
        // Render table with all evaluation sections
        renderClassificationTable(data);
    }

    function renderClassificationStats(metrics) {
        const statsGrid = document.getElementById('statsGrid');
        statsGrid.innerHTML = '';

        // Calculate overall statistics
        let totalModels = 0;
        let avgAccuracy = 0;
        let avgF1 = 0;
        let bestModel = '';
        let bestAccuracy = 0;

        Object.entries(metrics).forEach(([modelName, folds]) => {
            totalModels++;
            const summary = folds.Summary;
            if (summary && summary.Accuracy) {
                // Handle both direct value and {mean, std} structure
                const acc = (typeof summary.Accuracy === 'object' ? summary.Accuracy.mean : summary.Accuracy) * 100;
                const f1 = (typeof summary.F1Score === 'object' ? summary.F1Score.mean : summary.F1Score || 0) * 100;
                
                avgAccuracy += acc;
                avgF1 += f1;
                
                if (acc > bestAccuracy) {
                    bestAccuracy = acc;
                    bestModel = modelName;
                }
            }
        });

        avgAccuracy /= totalModels;
        avgF1 /= totalModels;

        const stats = [
            {
                icon: 'fa-brain',
                label: 'Total de Modelos',
                value: totalModels,
                color: 'var(--primary)',
                trend: null
            },
            {
                icon: 'fa-percentage',
                label: 'Accuracy Média',
                value: avgAccuracy.toFixed(2) + '%',
                color: 'var(--success)',
                trend: { value: '+2.5%', up: true }
            },
            {
                icon: 'fa-chart-line',
                label: 'F1-Score Médio',
                value: avgF1.toFixed(2) + '%',
                color: 'var(--info)',
                trend: { value: '+1.8%', up: true }
            },
            {
                icon: 'fa-trophy',
                label: 'Melhor Modelo',
                value: bestModel,
                subvalue: bestAccuracy.toFixed(2) + '%',
                color: 'var(--warning)',
                trend: null
            }
        ];

        stats.forEach(stat => {
            const card = document.createElement('div');
            card.className = 'stat-card';
            card.innerHTML = `
                <div class="stat-header">
                    <div class="stat-icon" style="background: ${stat.color}20; color: ${stat.color};">
                        <i class="fas ${stat.icon}"></i>
                    </div>
                </div>
                <div class="stat-value">${stat.value}</div>
                ${stat.subvalue ? `<div class="stat-label">${stat.subvalue}</div>` : ''}
                <div class="stat-label">${stat.label}</div>
                ${stat.trend ? `
                    <div class="stat-trend ${stat.trend.up ? 'trend-up' : 'trend-down'}">
                        <i class="fas fa-arrow-${stat.trend.up ? 'up' : 'down'}"></i>
                        ${stat.trend.value}
                    </div>
                ` : ''}
            `;
            statsGrid.appendChild(card);
        });
    }

    function renderClassificationCharts(metrics) {
        const container = document.getElementById('chartsContainer');
        container.innerHTML = '';

        // Destroy existing charts
        Object.values(charts).forEach(chart => chart?.destroy());
        charts = {};

        // Prepare data for charts
        const chartData = prepareClassificationChartData(metrics);

        // Create chart cards
        const chartConfigs = [
            {
                id: 'accuracyChart',
                title: 'Accuracy por Modelo',
                type: 'bar',
                data: chartData.accuracy,
                color: 'rgba(59, 130, 246, 0.8)'
            },
            {
                id: 'f1Chart',
                title: 'F1-Score por Modelo',
                type: 'bar',
                data: chartData.f1,
                color: 'rgba(16, 185, 129, 0.8)'
            },
            {
                id: 'precisionRecallChart',
                title: 'Precision vs Recall',
                type: 'radar',
                data: [chartData.precision, chartData.recall],
                labels: ['Precision', 'Recall']
            },
            {
                id: 'errorChart',
                title: 'Métricas de Erro',
                type: 'bar',
                data: [chartData.mse, chartData.mae],
                labels: ['MSE', 'MAE']
            }
        ];

        chartConfigs.forEach(config => {
            const card = document.createElement('div');
            card.className = 'chart-card';
            card.innerHTML = `
                <div class="chart-header">
                    <h3 class="chart-title">${config.title}</h3>
                </div>
                <div class="chart-container">
                    <canvas id="${config.id}"></canvas>
                </div>
            `;
            container.appendChild(card);
        });

        // Create charts
        setTimeout(() => createClassificationCharts(chartData), 100);
    }

    function prepareClassificationChartData(metrics) {
        const labels = [];
        const accuracy = [];
        const f1 = [];
        const precision = [];
        const recall = [];
        const mse = [];
        const mae = [];

        Object.entries(metrics).forEach(([modelName, folds]) => {
            const summary = folds.Summary;
            if (summary) {
                labels.push(modelName);
                accuracy.push((getValue(summary.Accuracy) * 100).toFixed(2));
                f1.push((getValue(summary.F1Score) * 100).toFixed(2));
                precision.push((getValue(summary.Precision) * 100).toFixed(2));
                recall.push((getValue(summary.Recall) * 100).toFixed(2));
                mse.push(getValue(summary.MeanSquareError).toFixed(4));
                mae.push(getValue(summary.MeanAbsoluteError).toFixed(4));
            }
        });

        return { labels, accuracy, f1, precision, recall, mse, mae };
    }

    function createClassificationCharts(chartData) {
        const isDark = document.body.classList.contains('dark-mode');
        const textColor = isDark ? '#f1f5f9' : '#0f172a';
        const gridColor = isDark ? '#334155' : '#e5e7eb';

        // Accuracy Chart
        charts.accuracy = new Chart(document.getElementById('accuracyChart'), {
            type: 'bar',
            data: {
                labels: chartData.labels,
                datasets: [{
                    label: 'Accuracy (%)',
                    data: chartData.accuracy,
                    backgroundColor: 'rgba(59, 130, 246, 0.8)',
                    borderColor: 'rgba(59, 130, 246, 1)',
                    borderWidth: 2,
                    borderRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { labels: { color: textColor } },
                    tooltip: {
                        backgroundColor: isDark ? '#1e293b' : '#ffffff',
                        titleColor: isDark ? '#f1f5f9' : '#0f172a',
                        bodyColor: isDark ? '#f1f5f9' : '#0f172a',
                        borderColor: gridColor,
                        borderWidth: 1
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        grid: { color: gridColor },
                        ticks: { color: textColor }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: textColor }
                    }
                }
            }
        });

        // F1-Score Chart
        charts.f1 = new Chart(document.getElementById('f1Chart'), {
            type: 'bar',
            data: {
                labels: chartData.labels,
                datasets: [{
                    label: 'F1-Score (%)',
                    data: chartData.f1,
                    backgroundColor: 'rgba(16, 185, 129, 0.8)',
                    borderColor: 'rgba(16, 185, 129, 1)',
                    borderWidth: 2,
                    borderRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { labels: { color: textColor } },
                    tooltip: {
                        backgroundColor: isDark ? '#1e293b' : '#ffffff',
                        titleColor: isDark ? '#f1f5f9' : '#0f172a',
                        bodyColor: isDark ? '#f1f5f9' : '#0f172a',
                        borderColor: gridColor,
                        borderWidth: 1
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        grid: { color: gridColor },
                        ticks: { color: textColor }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: textColor }
                    }
                }
            }
        });

        // Precision vs Recall Radar Chart
        charts.radar = new Chart(document.getElementById('precisionRecallChart'), {
            type: 'radar',
            data: {
                labels: chartData.labels,
                datasets: [
                    {
                        label: 'Precision',
                        data: chartData.precision,
                        backgroundColor: 'rgba(139, 92, 246, 0.2)',
                        borderColor: 'rgba(139, 92, 246, 1)',
                        borderWidth: 2
                    },
                    {
                        label: 'Recall',
                        data: chartData.recall,
                        backgroundColor: 'rgba(6, 182, 212, 0.2)',
                        borderColor: 'rgba(6, 182, 212, 1)',
                        borderWidth: 2
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { labels: { color: textColor } }
                },
                scales: {
                    r: {
                        beginAtZero: true,
                        max: 100,
                        grid: { color: gridColor },
                        ticks: { color: textColor },
                        pointLabels: { color: textColor }
                    }
                }
            }
        });

        // Error Chart
        charts.error = new Chart(document.getElementById('errorChart'), {
            type: 'bar',
            data: {
                labels: chartData.labels,
                datasets: [
                    {
                        label: 'MSE',
                        data: chartData.mse,
                        backgroundColor: 'rgba(239, 68, 68, 0.8)',
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 2,
                        borderRadius: 8
                    },
                    {
                        label: 'MAE',
                        data: chartData.mae,
                        backgroundColor: 'rgba(245, 158, 11, 0.8)',
                        borderColor: 'rgba(245, 158, 11, 1)',
                        borderWidth: 2,
                        borderRadius: 8
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { labels: { color: textColor } },
                    tooltip: {
                        backgroundColor: isDark ? '#1e293b' : '#ffffff',
                        titleColor: isDark ? '#f1f5f9' : '#0f172a',
                        bodyColor: isDark ? '#f1f5f9' : '#0f172a',
                        borderColor: gridColor,
                        borderWidth: 1
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: { color: gridColor },
                        ticks: { color: textColor }
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: textColor }
                    }
                }
            }
        });
    }

    function renderClassificationTable(data) {
        const tbody = document.getElementById('metricsTableBody');
        tbody.innerHTML = '';

        // Define evaluation sections to check
        const evaluationSections = ['TS-TR', 'TR-TS', 'TR-TR'];
        
        // Check if we have ClassificationMetrics (old format) or evaluation sections (new format)
        let hasOldFormat = data.ClassificationMetrics;
        let hasNewFormat = evaluationSections.some(section => data[section]);

        if (hasNewFormat) {
            // New format: iterate through evaluation sections
            evaluationSections.forEach(evalSection => {
                if (!data[evalSection]) return;
                
                const metrics = data[evalSection];
                
                Object.entries(metrics).forEach(([modelName, folds]) => {
                    Object.entries(folds).forEach(([fold, foldData]) => {
                        if (fold === 'Summary') {
                            // Show summary as separate row
                            const row = document.createElement('tr');
                            row.style.fontWeight = 'bold';
                            row.style.background = isDarkMode ? '#0f172a' : '#f9fafb';
                            
                            const accuracy = getValue(foldData.Accuracy) * 100;
                            const badge = accuracy >= 70 ? 'badge-success' : accuracy >= 50 ? 'badge-warning' : 'badge-danger';
                            
                            row.innerHTML = `
                                <td>${evalSection} - ${modelName}</td>
                                <td>Média (Summary)</td>
                                <td><span class="metric-badge ${badge}">${accuracy.toFixed(2)}%</span></td>
                                <td>${(getValue(foldData.F1Score) * 100).toFixed(2)}%</td>
                                <td>${(getValue(foldData.Precision) * 100).toFixed(2)}%</td>
                                <td>${(getValue(foldData.Recall) * 100).toFixed(2)}%</td>
                                <td>${getValue(foldData.MeanSquareError).toFixed(4)}</td>
                                <td>${getValue(foldData.MeanAbsoluteError).toFixed(4)}</td>
                            `;
                            tbody.appendChild(row);
                        } else if (fold.includes('Fold')) {
                            const row = document.createElement('tr');
                            
                            const accuracy = getValue(foldData.Accuracy) * 100;
                            const badge = accuracy >= 70 ? 'badge-success' : accuracy >= 50 ? 'badge-warning' : 'badge-danger';
                            
                            row.innerHTML = `
                                <td>${evalSection} - ${modelName}</td>
                                <td>${fold}</td>
                                <td><span class="metric-badge ${badge}">${accuracy.toFixed(2)}%</span></td>
                                <td>${(getValue(foldData.F1Score) * 100).toFixed(2)}%</td>
                                <td>${(getValue(foldData.Precision) * 100).toFixed(2)}%</td>
                                <td>${(getValue(foldData.Recall) * 100).toFixed(2)}%</td>
                                <td>${getValue(foldData.MeanSquareError).toFixed(4)}</td>
                                <td>${getValue(foldData.MeanAbsoluteError).toFixed(4)}</td>
                            `;
                            tbody.appendChild(row);
                        }
                    });
                });
            });
        } else if (hasOldFormat) {
            // Old format: use ClassificationMetrics directly
            const metrics = data.ClassificationMetrics;
            
            Object.entries(metrics).forEach(([modelName, folds]) => {
                Object.entries(folds).forEach(([fold, foldData]) => {
                    if (fold === 'Summary') {
                        // Show summary as separate row
                        const row = document.createElement('tr');
                        row.style.fontWeight = 'bold';
                        row.style.background = isDarkMode ? '#0f172a' : '#f9fafb';
                        
                        const accuracy = getValue(foldData.Accuracy) * 100;
                        const badge = accuracy >= 70 ? 'badge-success' : accuracy >= 50 ? 'badge-warning' : 'badge-danger';
                        
                        row.innerHTML = `
                            <td>${modelName}</td>
                            <td>Média (Summary)</td>
                            <td><span class="metric-badge ${badge}">${accuracy.toFixed(2)}%</span></td>
                            <td>${(getValue(foldData.F1Score) * 100).toFixed(2)}%</td>
                            <td>${(getValue(foldData.Precision) * 100).toFixed(2)}%</td>
                            <td>${(getValue(foldData.Recall) * 100).toFixed(2)}%</td>
                            <td>${getValue(foldData.MeanSquareError).toFixed(4)}</td>
                            <td>${getValue(foldData.MeanAbsoluteError).toFixed(4)}</td>
                        `;
                        tbody.appendChild(row);
                    } else if (fold.includes('Fold')) {
                        const row = document.createElement('tr');
                        
                        const accuracy = getValue(foldData.Accuracy) * 100;
                        const badge = accuracy >= 70 ? 'badge-success' : accuracy >= 50 ? 'badge-warning' : 'badge-danger';
                        
                        row.innerHTML = `
                            <td>${modelName}</td>
                            <td>${fold}</td>
                            <td><span class="metric-badge ${badge}">${accuracy.toFixed(2)}%</span></td>
                            <td>${(getValue(foldData.F1Score) * 100).toFixed(2)}%</td>
                            <td>${(getValue(foldData.Precision) * 100).toFixed(2)}%</td>
                            <td>${(getValue(foldData.Recall) * 100).toFixed(2)}%</td>
                            <td>${getValue(foldData.MeanSquareError).toFixed(4)}</td>
                            <td>${getValue(foldData.MeanAbsoluteError).toFixed(4)}</td>
                        `;
                        tbody.appendChild(row);
                    }
                });
            });
        }
    }

    function renderDistanceMetrics(data) {
        if (!data.DistanceMetrics) {
            showNoDataMessage();
            return;
        }

        const metrics = data.DistanceMetrics;
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        
        // Clear previous content
        statsGrid.innerHTML = '';
        container.innerHTML = '';
        tbody.innerHTML = '';

        // Render stats - get averages from Summary of each comparison type
        const distanceTypes = ['EuclideanDistance', 'HellingerDistance', 'ManhattanDistance', 'HammingDistance', 'JaccardDistance'];
        const comparisonTypes = Object.keys(metrics); // S-S, S-R, R-S, R-R
        
        // Create stats for the first few distance metrics from first comparison type
        const firstType = comparisonTypes[0];
        if (metrics[firstType] && metrics[firstType].Summary) {
            const stats = [];
            const colors = ['var(--primary)', 'var(--success)', 'var(--warning)', 'var(--info)'];
            const icons = ['fa-ruler', 'fa-ruler-horizontal', 'fa-ruler-vertical', 'fa-ruler-combined'];
            
            distanceTypes.slice(0, 4).forEach((distType, i) => {
                if (metrics[firstType].Summary[distType]) {
                    stats.push({
                        icon: icons[i],
                        label: `${firstType} - ${distType}`,
                        value: getValue(metrics[firstType].Summary[distType]).toFixed(4),
                        color: colors[i]
                    });
                }
            });

            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <div class="stat-header">
                        <div class="stat-icon" style="background: ${stat.color}20; color: ${stat.color};">
                            <i class="fas ${stat.icon}"></i>
                        </div>
                    </div>
                    <div class="stat-value">${stat.value}</div>
                    <div class="stat-label">${stat.label}</div>
                `;
                statsGrid.appendChild(card);
            });
        }

        // Render charts - one chart per comparison type
        comparisonTypes.forEach(compType => {
            const chartCard = document.createElement('div');
            chartCard.className = 'chart-card';
            chartCard.innerHTML = `
                <div class="chart-header">
                    <h3 class="chart-title">Distâncias - ${compType}</h3>
                </div>
                <div class="chart-container">
                    <canvas id="distanceChart_${compType}"></canvas>
                </div>
            `;
            container.appendChild(chartCard);
        });

        // Create charts
        setTimeout(() => {
            const isDark = document.body.classList.contains('dark-mode');
            const textColor = isDark ? '#f1f5f9' : '#0f172a';
            const gridColor = isDark ? '#334155' : '#e5e7eb';

            comparisonTypes.forEach(compType => {
                const compData = metrics[compType];
                if (!compData) return;

                const labels = [];
                const datasets = {};

                // Collect fold data
                Object.entries(compData).forEach(([fold, foldData]) => {
                    if (fold !== 'Summary' && foldData) {
                        labels.push(fold);
                        
                        distanceTypes.forEach(distType => {
                            if (!datasets[distType]) {
                                datasets[distType] = [];
                            }
                            datasets[distType].push(getValue(foldData[distType]).toFixed(4));
                        });
                    }
                });

                const colors = [
                    'rgba(59, 130, 246, 0.8)',
                    'rgba(16, 185, 129, 0.8)',
                    'rgba(245, 158, 11, 0.8)',
                    'rgba(239, 68, 68, 0.8)',
                    'rgba(139, 92, 246, 0.8)'
                ];

                const chartDatasets = Object.entries(datasets).map(([name, data], i) => ({
                    label: name,
                    data: data,
                    backgroundColor: colors[i],
                    borderColor: colors[i].replace('0.8', '1'),
                    borderWidth: 2,
                    borderRadius: 8
                }));

                charts[`distance_${compType}`] = new Chart(document.getElementById(`distanceChart_${compType}`), {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: chartDatasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: textColor } }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                grid: { color: gridColor },
                                ticks: { color: textColor }
                            },
                            x: {
                                grid: { display: false },
                                ticks: { color: textColor }
                            }
                        }
                    }
                });
            });
        }, 100);

        // Render table
        const thead = document.querySelector('#metricsTable thead tr');
        thead.innerHTML = `
            <th>Tipo de Comparação</th>
            <th>Fold</th>
            <th>Euclidean</th>
            <th>Hellinger</th>
            <th>Manhattan</th>
            <th>Hamming</th>
            <th>Jaccard</th>
        `;

        Object.entries(metrics).forEach(([compType, folds]) => {
            Object.entries(folds).forEach(([fold, data]) => {
                if (data && typeof data === 'object') {
                    const row = document.createElement('tr');
                    if (fold === 'Summary') {
                        row.style.fontWeight = 'bold';
                        row.style.background = isDarkMode ? '#0f172a' : '#f9fafb';
                    }
                    
                    row.innerHTML = `
                        <td>${compType}</td>
                        <td>${fold === 'Summary' ? 'Média (Summary)' : fold}</td>
                        <td>${getValue(data.EuclideanDistance, 'N/A') !== 'N/A' ? getValue(data.EuclideanDistance).toFixed(4) : 'N/A'}</td>
                        <td>${getValue(data.HellingerDistance, 'N/A') !== 'N/A' ? getValue(data.HellingerDistance).toFixed(4) : 'N/A'}</td>
                        <td>${getValue(data.ManhattanDistance, 'N/A') !== 'N/A' ? getValue(data.ManhattanDistance).toFixed(4) : 'N/A'}</td>
                        <td>${getValue(data.HammingDistance, 'N/A') !== 'N/A' ? getValue(data.HammingDistance).toFixed(4) : 'N/A'}</td>
                        <td>${getValue(data.JaccardDistance, 'N/A') !== 'N/A' ? getValue(data.JaccardDistance).toFixed(4) : 'N/A'}</td>
                    `;
                    tbody.appendChild(row);
                }
            });
        });
    }

    function renderEfficiencyMetrics(data) {
        if (!data.EfficiencyMetrics) {
            showNoDataMessage();
            return;
        }

        const metrics = data.EfficiencyMetrics;
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        
        statsGrid.innerHTML = '';
        container.innerHTML = '';
        tbody.innerHTML = '';

        // Render stats from Summary
        if (metrics.Summary) {
            const summary = metrics.Summary;
            const stats = [
                {
                    icon: 'fa-microchip',
                    label: 'CPU Médio',
                    value: getValue(summary['Process_CPU_%']).toFixed(2) + '%',
                    color: 'var(--primary)'
                },
                {
                    icon: 'fa-memory',
                    label: 'Memória Média',
                    value: getValue(summary.Process_Memory_MB).toFixed(2) + ' MB',
                    color: 'var(--success)'
                },
                {
                    icon: 'fa-clock',
                    label: 'Tempo de Treinamento',
                    value: (getValue(summary.Time_training_ms) / 1000).toFixed(2) + ' s',
                    color: 'var(--warning)'
                },
                {
                    icon: 'fa-bolt',
                    label: 'Tempo de Geração',
                    value: getValue(summary.Time_generating_ms).toFixed(2) + ' ms',
                    color: 'var(--info)'
                }
            ];

            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <div class="stat-header">
                        <div class="stat-icon" style="background: ${stat.color}20; color: ${stat.color};">
                            <i class="fas ${stat.icon}"></i>
                        </div>
                    </div>
                    <div class="stat-value">${stat.value}</div>
                    <div class="stat-label">${stat.label}</div>
                `;
                statsGrid.appendChild(card);
            });
        }

        // Render charts
        const chartCard = document.createElement('div');
        chartCard.className = 'chart-card';
        chartCard.style.gridColumn = '1 / -1';
        chartCard.innerHTML = `
            <div class="chart-header">
                <h3 class="chart-title">Métricas de Eficiência por Fold</h3>
            </div>
            <div class="chart-container">
                <canvas id="efficiencyChart"></canvas>
            </div>
        `;
        container.appendChild(chartCard);

        // Create chart
        setTimeout(() => {
            const labels = [];
            const cpuData = [];
            const memoryData = [];
            const trainingTime = [];

            Object.entries(metrics).forEach(([fold, data]) => {
                if (fold !== 'Summary' && data) {
                    labels.push(fold);
                    cpuData.push(getValue(data['Process_CPU_%']).toFixed(2));
                    memoryData.push(getValue(data.Process_Memory_MB).toFixed(2));
                    trainingTime.push((getValue(data.Time_training_ms) / 1000).toFixed(2));
                }
            });

            const isDark = document.body.classList.contains('dark-mode');
            const textColor = isDark ? '#f1f5f9' : '#0f172a';
            const gridColor = isDark ? '#334155' : '#e5e7eb';

            charts.efficiency = new Chart(document.getElementById('efficiencyChart'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'CPU (%)',
                            data: cpuData,
                            borderColor: 'rgba(59, 130, 246, 1)',
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderWidth: 2,
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Memória (MB)',
                            data: memoryData,
                            borderColor: 'rgba(16, 185, 129, 1)',
                            backgroundColor: 'rgba(16, 185, 129, 0.2)',
                            borderWidth: 2,
                            tension: 0.4,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Tempo Treinamento (s)',
                            data: trainingTime,
                            borderColor: 'rgba(245, 158, 11, 1)',
                            backgroundColor: 'rgba(245, 158, 11, 0.2)',
                            borderWidth: 2,
                            tension: 0.4,
                            yAxisID: 'y2'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: textColor } }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: { display: true, text: 'CPU (%)', color: textColor },
                            grid: { color: gridColor },
                            ticks: { color: textColor }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Memória (MB)', color: textColor },
                            grid: { display: false },
                            ticks: { color: textColor }
                        },
                        y2: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Tempo (s)', color: textColor },
                            grid: { display: false },
                            ticks: { color: textColor }
                        },
                        x: {
                            grid: { display: false },
                            ticks: { color: textColor }
                        }
                    }
                }
            });
        }, 100);

        // Render table
        const thead = document.querySelector('#metricsTable thead tr');
        thead.innerHTML = `
            <th>Fold</th>
            <th>Process CPU %</th>
            <th>Process Memory MB</th>
            <th>System CPU %</th>
            <th>System Memory MB</th>
            <th>Training Time (s)</th>
            <th>Generating Time (ms)</th>
        `;

        Object.entries(metrics).forEach(([fold, data]) => {
            if (data && typeof data === 'object') {
                const row = document.createElement('tr');
                if (fold === 'Summary') {
                    row.style.fontWeight = 'bold';
                    row.style.background = isDarkMode ? '#0f172a' : '#f9fafb';
                }
                
                row.innerHTML = `
                    <td>${fold === 'Summary' ? 'Média (Summary)' : fold}</td>
                    <td>${getValue(data['Process_CPU_%']).toFixed(2)}</td>
                    <td>${getValue(data.Process_Memory_MB).toFixed(2)}</td>
                    <td>${getValue(data['System_CPU_%']).toFixed(2)}</td>
                    <td>${getValue(data.System_Memory_MB).toFixed(2)}</td>
                    <td>${(getValue(data.Time_training_ms) / 1000).toFixed(2)}</td>
                    <td>${getValue(data.Time_generating_ms).toFixed(2)}</td>
                `;
                tbody.appendChild(row);
            }
        });
    }

    function renderSDVMetrics(data) {
        if (!data.SDVMetrics) {
            showNoDataMessage();
            return;
        }

        const metrics = data.SDVMetrics;
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        
        statsGrid.innerHTML = '';
        container.innerHTML = '';
        tbody.innerHTML = '';

        // Render stats
        if (metrics.Summary) {
            const stats = [
                {
                    icon: 'fa-check-circle',
                    label: 'Diagnostic Score',
                    value: getValue(metrics.Summary.diagnostic).toFixed(4),
                    color: 'var(--success)'
                },
                {
                    icon: 'fa-star',
                    label: 'Quality Score',
                    value: getValue(metrics.Summary.quality).toFixed(4),
                    color: 'var(--warning)'
                }
            ];

            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <div class="stat-header">
                        <div class="stat-icon" style="background: ${stat.color}20; color: ${stat.color};">
                            <i class="fas ${stat.icon}"></i>
                        </div>
                    </div>
                    <div class="stat-value">${stat.value}</div>
                    <div class="stat-label">${stat.label}</div>
                `;
                statsGrid.appendChild(card);
            });
        }

        // Render chart
        const chartCard = document.createElement('div');
        chartCard.className = 'chart-card';
        chartCard.innerHTML = `
            <div class="chart-header">
                <h3 class="chart-title">SDV Metrics por Fold</h3>
            </div>
            <div class="chart-container">
                <canvas id="sdvChart"></canvas>
            </div>
        `;
        container.appendChild(chartCard);

        setTimeout(() => {
            const labels = [];
            const diagnostic = [];
            const quality = [];

            Object.entries(metrics).forEach(([fold, data]) => {
                if (fold !== 'Summary' && data) {
                    labels.push(fold);
                    diagnostic.push(getValue(data.diagnostic));
                    quality.push(getValue(data.quality));
                }
            });

            const isDark = document.body.classList.contains('dark-mode');
            const textColor = isDark ? '#f1f5f9' : '#0f172a';
            const gridColor = isDark ? '#334155' : '#e5e7eb';

            charts.sdv = new Chart(document.getElementById('sdvChart'), {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Diagnostic',
                            data: diagnostic,
                            backgroundColor: 'rgba(16, 185, 129, 0.8)',
                            borderColor: 'rgba(16, 185, 129, 1)',
                            borderWidth: 2,
                            borderRadius: 8
                        },
                        {
                            label: 'Quality',
                            data: quality,
                            backgroundColor: 'rgba(245, 158, 11, 0.8)',
                            borderColor: 'rgba(245, 158, 11, 1)',
                            borderWidth: 2,
                            borderRadius: 8
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: textColor } }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { color: gridColor },
                            ticks: { color: textColor }
                        },
                        x: {
                            grid: { display: false },
                            ticks: { color: textColor }
                        }
                    }
                }
            });
        }, 100);

        // Render table
        const thead = document.querySelector('#metricsTable thead tr');
        thead.innerHTML = `
            <th>Fold</th>
            <th>Diagnostic Score</th>
            <th>Quality Score</th>
        `;

        Object.entries(metrics).forEach(([fold, data]) => {
            if (data && typeof data === 'object') {
                const row = document.createElement('tr');
                if (fold === 'Summary') {
                    row.style.fontWeight = 'bold';
                    row.style.background = isDarkMode ? '#0f172a' : '#f9fafb';
                }
                
                row.innerHTML = `
                    <td>${fold === 'Summary' ? 'Média (Summary)' : fold}</td>
                    <td>${getValue(data.diagnostic).toFixed(4)}</td>
                    <td>${getValue(data.quality).toFixed(4)}</td>
                `;
                tbody.appendChild(row);
            }
        });
    }

    function renderArguments(data) {
        if (!data.Arguments) {
            showNoDataMessage();
            return;
        }

        const args = data.Arguments;
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        
        statsGrid.innerHTML = '';
        container.innerHTML = '';
        tbody.innerHTML = '';

        // Show key arguments as stats
        const keyArgs = [
            { key: 'model_type', label: 'Tipo de Modelo', icon: 'fa-brain' },
            { key: 'number_k_folds', label: 'Número de Folds', icon: 'fa-layer-group' },
            { key: 'adversarial_number_epochs', label: 'Epochs', icon: 'fa-sync' },
            { key: 'adversarial_batch_size', label: 'Batch Size', icon: 'fa-cubes' }
        ];

        const colors = ['var(--primary)', 'var(--success)', 'var(--warning)', 'var(--info)'];

        keyArgs.forEach((arg, i) => {
            const value = args[arg.key];
            if (value !== undefined) {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <div class="stat-header">
                        <div class="stat-icon" style="background: ${colors[i]}20; color: ${colors[i]};">
                            <i class="fas ${arg.icon}"></i>
                        </div>
                    </div>
                    <div class="stat-value">${typeof value === 'object' ? JSON.stringify(value) : value}</div>
                    <div class="stat-label">${arg.label}</div>
                `;
                statsGrid.appendChild(card);
            }
        });

        // Show all arguments in a formatted view
        const argsCard = document.createElement('div');
        argsCard.className = 'chart-card';
        argsCard.style.gridColumn = '1 / -1';
        argsCard.innerHTML = `
            <div class="chart-header">
                <h3 class="chart-title">Todos os Argumentos</h3>
            </div>
            <div style="padding: 1rem; max-height: 400px; overflow-y: auto;">
                <pre style="background: ${isDarkMode ? '#0f172a' : '#f9fafb'}; padding: 1rem; border-radius: 0.5rem; font-size: 0.875rem;">${JSON.stringify(args, null, 2)}</pre>
            </div>
        `;
        container.appendChild(argsCard);

        // Render table
        const thead = document.querySelector('#metricsTable thead tr');
        thead.innerHTML = `
            <th>Parâmetro</th>
            <th>Valor</th>
        `;

        Object.entries(args).forEach(([key, value]) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><code>${key}</code></td>
                <td>${typeof value === 'object' ? JSON.stringify(value) : value}</td>
            `;
            tbody.appendChild(row);
        });
    }

    function showNoDataMessage() {
        const statsGrid = document.getElementById('statsGrid');
        const container = document.getElementById('chartsContainer');
        const tbody = document.getElementById('metricsTableBody');
        
        statsGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; padding: 2rem; color: #9ca3af;">Nenhum dado disponível para esta seção</div>';
        container.innerHTML = '';
        tbody.innerHTML = '';
    }

    // UI Functions
    function toggleSidebar() {
        const sidebar = document.getElementById('sidebar');
        const mainContent = document.getElementById('mainContent');
        const menuToggle = document.getElementById('menuToggle');

        isSidebarOpen = !isSidebarOpen;

        if (isSidebarOpen) {
            sidebar.classList.remove('collapsed');
            mainContent.classList.remove('expanded');
            menuToggle.innerHTML = '<i class="fas fa-bars"></i>';
        } else {
            sidebar.classList.add('collapsed');
            mainContent.classList.add('expanded');
            menuToggle.innerHTML = '<i class="fas fa-times"></i>';
        }
    }

    function toggleTheme() {
        isDarkMode = !isDarkMode;
        document.body.classList.toggle('dark-mode');
        document.getElementById('themeIcon').className = isDarkMode ? 'fas fa-sun' : 'fas fa-moon';

        if (currentExperiment) {
            renderDashboard();
        }
    }

    function exportCurrentExperiment() {
        if (!currentExperiment) {
            showNotification('Nenhum experimento selecionado', 'error');
            return;
        }

        const data = allExperiments[currentExperiment];
        let csv = '';
        
        if (currentTab === 'classification' && data.ClassificationMetrics) {
            csv = 'Modelo,Fold,Accuracy,F1-Score,Precision,Recall,MSE,MAE\n';
            Object.entries(data.ClassificationMetrics).forEach(([model, folds]) => {
                Object.entries(folds).forEach(([fold, metrics]) => {
                    if (metrics && typeof metrics === 'object') {
                        const acc = getValue(metrics.Accuracy) * 100;
                        const f1 = getValue(metrics.F1Score) * 100;
                        const prec = getValue(metrics.Precision) * 100;
                        const rec = getValue(metrics.Recall) * 100;
                        const mse = getValue(metrics.MeanSquareError);
                        const mae = getValue(metrics.MeanAbsoluteError);
                        
                        csv += `${model},${fold},${acc.toFixed(2)},${f1.toFixed(2)},${prec.toFixed(2)},${rec.toFixed(2)},${mse.toFixed(4)},${mae.toFixed(4)}\n`;
                    }
                });
            });
        } else {
            csv = JSON.stringify(data, null, 2);
        }

        const blob = new Blob([csv], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const displayName = experimentMetadata[currentExperiment]?.originalName || currentExperiment;
        a.download = `${displayName}_${currentTab}_report.csv`;
        a.click();
        window.URL.revokeObjectURL(url);
        
        showNotification('Arquivo CSV exportado com sucesso', 'success');
    }

    function exportAsPDF() {
        showNotification('Exportação PDF em desenvolvimento', 'info');
    }

    function shareExperiment() {
        const url = window.location.href;
        navigator.clipboard.writeText(url).then(() => {
            showNotification('Link copiado para área de transferência!', 'success');
        }).catch(() => {
            showNotification('Erro ao copiar link', 'error');
        });
    }

    function refreshExperiment() {
        if (currentExperiment) {
            renderDashboard();
        }
    }

    function refreshCharts() {
        if (currentExperiment) {
            renderDashboard();
            showNotification('Gráficos atualizados', 'success');
        }
    }

    function downloadCharts() {
        showNotification('Download de gráficos em desenvolvimento', 'info');
    }

    function generateReport() {
        showNotification('Funcionalidade de relatório em desenvolvimento', 'info');
    }

    function filterTable(searchTerm) {
        const table = document.getElementById('metricsTable');
        const rows = table.getElementsByTagName('tr');

        for (let i = 1; i < rows.length; i++) {
            const firstCell = rows[i].cells[0]?.textContent || '';
            if (firstCell.toLowerCase().includes(searchTerm.toLowerCase())) {
                rows[i].style.display = '';
            } else {
                rows[i].style.display = 'none';
            }
        }
    }

    function filterByMetric(criteria) {
        if (currentTab !== 'classification') return;
        
        const table = document.getElementById('metricsTable');
        const rows = table.getElementsByTagName('tr');

        for (let i = 1; i < rows.length; i++) {
            const accCell = rows[i].cells[2];
            if (!accCell) continue;
            
            const accText = accCell.textContent;
            const acc = parseFloat(accText.replace('%', ''));

            let show = true;
            if (criteria === 'high' && acc < 70) show = false;
            if (criteria === 'medium' && (acc < 50 || acc >= 70)) show = false;
            if (criteria === 'low' && acc >= 50) show = false;

            rows[i].style.display = show ? '' : 'none';
        }
    }

    function sortTable(columnIndex) {
        const table = document.getElementById('metricsTable');
        const tbody = table.getElementsByTagName('tbody')[0];
        const rows = Array.from(tbody.getElementsByTagName('tr'));

        rows.sort((a, b) => {
            const aVal = a.cells[columnIndex]?.textContent || '';
            const bVal = b.cells[columnIndex]?.textContent || '';

            const aNum = parseFloat(aVal.replace(/[^0-9.-]/g, ''));
            const bNum = parseFloat(bVal.replace(/[^0-9.-]/g, ''));

            if (!isNaN(aNum) && !isNaN(bNum)) {
                return bNum - aNum;
            }
            return aVal.localeCompare(bVal);
        });

        rows.forEach(row => tbody.appendChild(row));
    }

    function toggleComparisonMode() {
        comparisonMode = !comparisonMode;
        alert(comparisonMode ? 'Modo comparação ativado!' : 'Modo comparação desativado!');
    }

    function compareExperiments() {
        const experimentNames = Object.keys(allExperiments);
        if (experimentNames.length < 2) {
            showNotification('É necessário ter pelo menos 2 experimentos para comparar', 'error');
            return;
        }
        
        // Create comparison data
        let comparisonData = 'Experimento,';
        
        // Get metric names from first experiment
        const firstExp = allExperiments[experimentNames[0]];
        const evaluationSections = ['TS-TR', 'TR-TS', 'TR-TR'];
        
        // Try to get classification data from evaluation sections or ClassificationMetrics
        let classificationData = null;
        for (const section of evaluationSections) {
            if (firstExp[section]) {
                classificationData = firstExp[section];
                break;
            }
        }
        
        if (!classificationData && firstExp.ClassificationMetrics) {
            classificationData = firstExp.ClassificationMetrics;
        }
        
        if (classificationData) {
            const firstModel = Object.keys(classificationData)[0];
            const summary = classificationData[firstModel].Summary;
            if (summary) {
                const metrics = Object.keys(summary).filter(k => k !== 'Summary');
                comparisonData += metrics.join(',') + '\n';
                
                // Add data for each experiment
                experimentNames.forEach(expName => {
                    const exp = allExperiments[expName];
                    const displayName = experimentMetadata[expName]?.originalName || expName;
                    comparisonData += `${displayName},`;
                    
                    // Get classification data for this experiment
                    let expClassData = null;
                    for (const section of evaluationSections) {
                        if (exp[section]) {
                            expClassData = exp[section];
                            break;
                        }
                    }
                    
                    if (!expClassData && exp.ClassificationMetrics) {
                        expClassData = exp.ClassificationMetrics;
                    }
                    
                    if (expClassData) {
                        // Average across all models
                        let avgMetrics = {};
                        let modelCount = 0;
                        
                        Object.values(expClassData).forEach(model => {
                            if (model.Summary) {
                                modelCount++;
                                metrics.forEach(metric => {
                                    if (!avgMetrics[metric]) avgMetrics[metric] = 0;
                                    avgMetrics[metric] += getValue(model.Summary[metric]);
                                });
                            }
                        });
                        
                        // Calculate averages
                        metrics.forEach(metric => {
                            const avg = modelCount > 0 ? (avgMetrics[metric] / modelCount).toFixed(4) : '0';
                            comparisonData += avg + ',';
                        });
                        comparisonData = comparisonData.slice(0, -1) + '\n';
                    }
                });
            }
        }
        
        // Download comparison CSV
        const blob = new Blob([comparisonData], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'experiments_comparison.csv';
        a.click();
        window.URL.revokeObjectURL(url);
        
        showNotification('Comparação exportada com sucesso', 'success');
    }

    function exportAllExperiments() {
        if (Object.keys(allExperiments).length === 0) {
            showNotification('Nenhum experimento para exportar', 'error');
            return;
        }
        
        // Create a combined JSON with all experiments
        const combinedData = {
            exportDate: new Date().toISOString(),
            experimentsCount: Object.keys(allExperiments).length,
            experiments: {}
        };
        
        Object.entries(allExperiments).forEach(([name, data]) => {
            const displayName = experimentMetadata[name]?.originalName || name;
            combinedData.experiments[displayName] = {
                metadata: experimentMetadata[name],
                data: data
            };
        });
        
        const json = JSON.stringify(combinedData, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `all_experiments_${new Date().getTime()}.json`;
        a.click();
        window.URL.revokeObjectURL(url);
        
        showNotification(`${Object.keys(allExperiments).length} experimentos exportados`, 'success');
    }

    function downloadAllReports() {
        alert('Baixando todos os relatórios...');
    }

    function showNotificationsCenter() {
        showNotification('Central de notificações em desenvolvimento', 'info');
    }

    function showSettings() {
        showNotification('Configurações em desenvolvimento', 'info');
    }

    function resetDashboard() {
        if (confirm('Deseja limpar todos os dados e voltar ao início?')) {
            const count = Object.keys(allExperiments).length;
            
            allExperiments = {};
            experimentMetadata = {};
            currentExperiment = null;
            currentTab = 'classification';

            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('dashboardContent').style.display = 'none';
            document.getElementById('experimentList').innerHTML = '';
            document.getElementById('totalExperiments').textContent = '0';

            Object.values(charts).forEach(chart => chart?.destroy());
            charts = {};
            
            showNotification(`${count} experimento(s) removido(s)`, 'success');
        }
    }

    // Mobile responsiveness
    if (window.innerWidth < 1024) {
        document.getElementById('sidebar').classList.add('collapsed');
        document.getElementById('mainContent').classList.add('expanded');
        isSidebarOpen = false;
    }
</script>
</body>
</html>
